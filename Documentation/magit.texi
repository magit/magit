\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename magit.info
@settitle Magit User Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
@quotation
Copyright (C) 2015-2017 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
@end quotation
@end copying

@dircategory Emacs
@direntry
* Magit: (magit).       Using Git from Emacs with Magit.
@end direntry

@finalout
@titlepage
@title Magit User Manual
@subtitle for version 2.11
@author Jonas Bernoulli
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Magit User Manual

Magit is an interface to the version control system Git, implemented
as an Emacs package.  Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even experienced
Git users to perform almost all of their daily version control tasks
directly from within Emacs.  While many fine Git clients exist, only
Magit and Git itself deserve to be called porcelains.

@quotation
Copyright (C) 2015-2017 Jonas Bernoulli <jonas@@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
@end quotation
@end ifnottex

@menu
* Introduction::
* Installation::
* Getting Started::
* Interface Concepts::
* Inspecting::
* Manipulating::
* Transferring::
* Miscellaneous::
* Customizing::
* Plumbing::
* FAQ::
* Debugging Tools::
* Keystroke Index::
* Command Index::
* Function Index::
* Variable Index::

@detailmenu
--- The Detailed Node Listing ---


Installation

* Installing from an Elpa Archive::
* Installing from the Git Repository::
* Post-Installation Tasks::




Interface Concepts

* Modes and Buffers::
* Sections::
* Popup Buffers and Prefix Commands::
* Completion and Confirmation::
* Running Git::

Modes and Buffers

* Switching Buffers::
* Naming Buffers::
* Quitting Windows::
* Automatic Refreshing of Magit Buffers::
* Automatic Saving of File-Visiting Buffers::
* Automatic Reverting of File-Visiting Buffers::


Sections

* Section Movement::
* Section Visibility::
* Section Hooks::
* Section Types and Values::
* Section Options::




Running Git

* Viewing Git Output::
* Running Git Manually::
* Git Executable::
* Global Git Arguments::

Inspecting

* Status Buffer::
* Repository List::
* Logging::
* Diffing::
* Ediffing::
* References Buffer::
* Bisecting::
* Visiting Blobs::
* Blaming::

Status Buffer

* Status Sections::
* Status Header Sections::
* Status Module Sections::
* Status Options::



Logging

* Refreshing Logs::
* Log Buffer::
* Log Margin::
* Select from Log::
* Reflog::
* Cherries::


Diffing

* Refreshing Diffs::
* Diff Buffer::
* Diff Options::
* Revision Buffer::



References Buffer

* References Sections::

Manipulating

* Repository Setup::
* Staging and Unstaging::
* Applying::
* Committing::
* Branching::
* Merging::
* Resolving Conflicts::
* Rebasing::
* Cherry Picking::
* Resetting::
* Stashing::


Staging and Unstaging

* Staging from File-Visiting Buffers::



Committing

* Initiating a Commit::
* Editing Commit Messages::


Branching

* The Two Remotes::
* The Branch Popup::
* The Branch Config Popup::




Rebasing

* Editing Rebase Sequences::
* Information About In-Progress Rebase::


Cherry Picking

* Reverting::

Transferring

* Remotes::
* Fetching::
* Pulling::
* Pushing::
* Creating and Sending Patches::
* Applying Patches::



Miscellaneous

* Tagging::
* Notes::
* Submodules::
* Subtree::
* Common Commands::
* Wip Modes::
* Minor Mode for Buffers Visiting Files::
* Minor Mode for Buffers Visiting Blobs::



Submodules

* Listing Submodules::
* Submodule Popup::

Customizing

* Per-Repository Configuration::
* Essential Settings::


Essential Settings

* Safety::
* Performance::

Plumbing

* Calling Git::
* Section Plumbing::
* Refreshing Buffers::
* Conventions::

Calling Git

* Getting a Value from Git::
* Calling Git for Effect::


Section Plumbing

* Creating Sections::
* Section Selection::
* Matching Sections::



Conventions

* Confirmation and Completion::
* Theming Faces::

FAQ

* FAQ - How to @dots{}?::
* FAQ - Issues and Errors::

FAQ - How to @dots{}?

* How to show git's output?::
* How to install the gitman info manual?::
* How to show diffs for gpg-encrypted files?::
* How does branching and pushing work?::
* Can Magit be used as @code{ediff-version-control-package}?::


FAQ - Issues and Errors

* Magit is slow::
* I changed several thousand files at once and now Magit is unusable::
* I am having problems committing::
* I am using MS Windows and cannot push with Magit::
* I am using OS X and SOMETHING works in shell, but not in Magit: I am using OS X and SOMETHING works in shell but not in Magit. 
* Diffs contain control sequences::
* Expanding a file to show the diff causes it to disappear::
* Point is wrong in the @code{COMMIT_EDITMSG} buffer::
* The mode-line information isn't always up-to-date::
* Emacs 24.5 hangs when loading Magit: Emacs 245 hangs when loading Magit. 
@end detailmenu
@end menu

@node Introduction
@chapter Introduction

Magit is an interface to the version control system Git, implemented
as an Emacs package.  Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even experienced
Git users to perform almost all of their daily version control tasks
directly from within Emacs.  While many fine Git clients exist, only
Magit and Git itself deserve to be called porcelains.

Staging and otherwise applying changes is one of the most important
features in a Git porcelain and here Magit outshines anything else,
including Git itself.  Git's own staging interface (@code{git add --patch})
is so cumbersome that many users only use it in exceptional cases.
In Magit staging a hunk or even just part of a hunk is as trivial as
staging all changes made to a file.

The most visible part of Magit's interface is the status buffer, which
displays information about the current repository.  Its content is
created by running several Git commands and making their output
actionable.  Among other things, it displays information about the
current branch, lists unpulled and unpushed changes and contains
sections displaying the staged and unstaged changes.  That might sound
noisy, but, since sections are collapsible, it's not.

To stage or unstage a change one places the cursor on the change and
then types @code{s} or @code{u}.  The change can be a file or a hunk, or when the
region is active (i.e. when there is a selection) several files or
hunks, or even just part of a hunk.  The change or changes that these
commands - and many others - would act on are highlighted.

Magit also implements several other "apply variants" in addition to
staging and unstaging.  One can discard or reverse a change, or
apply it to the working tree.  Git's own porcelain only supports this
for staging and unstaging and you would have to do something like @code{git
diff ... | ??? | git apply ...} to discard, revert, or apply a single
hunk on the command line.  In fact that's exactly what Magit does
internally (which is what lead to the term "apply variants").

Magit isn't just for Git experts, but it does assume some prior
experience with Git as well as Emacs.  That being said, many users
have reported that using Magit was what finally taught them what Git
is capable of and how to use it to its fullest.  Other users
wished they had switched to Emacs sooner so that they would have
gotten their hands on Magit earlier.

While one has to know the basic features of Emacs to be able to make
full use of Magit, acquiring just enough Emacs skills doesn't take
long and is worth it, even for users who prefer other editors.  Vim
users are advised to give @uref{https://bitbucket.org/lyro/evil/wiki/Home, Evil}, the "Extensible VI Layer for Emacs",
and @uref{https://github.com/syl20bnr/spacemacs, Spacemacs}, an "Emacs starter-kit focused on Evil" a try.

Magit provides a consistent and efficient Git porcelain.  After a
short learning period, you will be able to perform most of your daily
version control tasks faster than you would on the command line.  You
will likely also start using features that seemed too daunting in the
past.

Magit fully embraces Git.  It exposes many advanced features using a
simple but flexible interface instead of only wrapping the trivial
ones like many GUI clients do.  Of course Magit supports logging,
cloning, pushing, and other commands that usually don't fail in
spectacular ways; but it also supports tasks that often cannot be
completed in a single step.  Magit fully supports tasks such as
merging, rebasing, cherry-picking, reverting, and blaming by not only
providing a command to initiate these tasks but also by displaying
context sensitive information along the way and providing commands
that are useful for resolving conflicts and resuming the sequence
after doing so.

Magit wraps and in many cases improves upon at least the following Git
porcelain commands: @code{add}, @code{am}, @code{bisect}, @code{blame}, @code{branch}, @code{checkout}, @code{cherry},
@code{cherry-pick}, @code{clean}, @code{clone}, @code{commit}, @code{config}, @code{describe}, @code{diff}, @code{fetch},
@code{format-patch}, @code{init}, @code{log}, @code{merge}, @code{merge-tree}, @code{mv}, @code{notes}, @code{pull}, @code{rebase},
@code{reflog}, @code{remote}, @code{request-pull}, @code{reset}, @code{revert}, @code{rm}, @code{show}, @code{stash},
@code{submodule}, @code{subtree}, @code{tag}, and @code{worktree.}  Many more Magit porcelain
commands are implemented on top of Git plumbing commands.

@node Installation
@chapter Installation

Magit can be installed using Emacs' package manager or manually from
its development repository.

@menu
* Installing from an Elpa Archive::
* Installing from the Git Repository::
* Post-Installation Tasks::
@end menu

@node Installing from an Elpa Archive
@section Installing from an Elpa Archive

Magit is available from Melpa and Melpa-Stable.  If you haven't used
Emacs' package manager before, then it is high time you familiarize
yourself with it by reading the documentation in the Emacs manual, see
@ref{Packages,,,emacs,}.  Then add one of the archives to
@code{package-archives}:

@itemize
@item
To use Melpa:
@end itemize

@lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
@end lisp

@itemize
@item
To use Melpa-Stable:
@end itemize

@lisp
(require 'package)
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
@end lisp

Once you have added your preferred archive, you need to update the
local package list using:

@example
M-x package-refresh-contents RET
@end example

Once you have done that, you can install Magit and its dependencies
using:

@example
M-x package-install RET magit RET
@end example

Now see @ref{Post-Installation Tasks}.

@node Installing from the Git Repository
@section Installing from the Git Repository

Magit depends on the @code{dash} and @code{with-editor} library which are available
from Melpa and Melpa-Stable.  Install them using @code{M-x package-install
RET <package> RET}.  Of course you may also install them manually from
their development repository, but I won't cover that here.

(An older release of Magit is also available from Marmalade, but no
new versions will be uploaded in the future.  Marmalade's maintainer
has stopped responding to requests from package maintainers who are
having difficulties or require him to create an account so that they
can upload their packages in the first place.)

Then clone the Magit repository:

@example
$ git clone https://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
$ cd ~/.emacs.d/site-lisp/magit
@end example

Then compile the libraries and generate the info manuals:

@example
$ make
@end example

If you haven't installed @code{dash} and @code{with-editor} using Elpa or at
@code{/path/to/magit/../<package>}, then you have to tell @code{make} where to find
them.  To do so create @code{/path/to/magit/config.mk} with the following
content before running @code{make}:

@example
LOAD_PATH  = -L /path/to/magit/lisp
LOAD_PATH += -L /path/to/dash
LOAD_PATH += -L /path/to/with-editor
@end example

Finally add this to your init file:

@lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/magit/lisp")
(require 'magit)

(with-eval-after-load 'info
  (info-initialize)
  (add-to-list 'Info-directory-list
               "~/.emacs.d/site-lisp/magit/Documentation/"))
@end lisp

Note that you have to add the @code{lisp} subdirectory to the @code{load-path}, not
the top-level of the repository, and that elements of @code{load-path} should
not end with a slash, while those of @code{Info-directory-list} should.

Instead of requiring the feature @code{magit}, you could load just the
autoload definitions, by loading the file @code{magit-autoloads.el}.

@lisp
(load "/path/to/magit/lisp/magit-autoloads")
@end lisp

Instead of running Magit directly from the repository by adding that
to the @code{load-path}, you might want to instead install it in some other
directory using @code{sudo make install} and setting @code{load-path} accordingly.

To update Magit use:

@example
$ git pull
$ make
@end example

At times it might be necessary to run @code{make clean all} instead.

To view all available targets use @code{make help}.

Now see @ref{Post-Installation Tasks}.

@node Post-Installation Tasks
@section Post-Installation Tasks

After installing Magit you should verify that you are indeed using the
Magit, Git, and Emacs releases you think you are using.  It's best to
restart Emacs before doing so, to make sure you are not using an
outdated value for @code{load-path}.

@example
M-x magit-version RET
@end example

should display something like

@example
Magit 2.8.0, Git 2.10.2, Emacs 25.1.1, gnu/linux
@end example

Then you might also want to read about options that many users likely
want to customize.  See @ref{Essential Settings}.

To be able to follow cross references to Git manpages found in this
manual, you might also have to manually install the @code{gitman} info manual,
or advice @code{Info-follow-nearest-node} to instead open the actual manpage.
See @ref{How to install the gitman info manual?}.

If you are completely new to Magit then see @ref{Getting Started}.

If you run into problems, then please see the @ref{FAQ}.  Also see the
@ref{Debugging Tools}.

And last but not least please consider making a donation, to ensure
that I can keep working on Magit.  See @uref{https://magit.vc/donations}.
for various donation options.

@node Getting Started
@chapter Getting Started

This short tutorial describes the most essential features that many
Magitians use on a daily basis.  It only scratches the surface but
should be enough to get you started.

IMPORTANT: It is safest if you clone some repository just for this
tutorial.  Alternatively you can use an existing local repository, but
if you do that, then you should commit all uncommitted changes before
proceeding.

To display information about the current Git repository, type @code{M-x
magit-status RET}.  You will be using this command a lot, and should
therefore give it a global key binding.  This is what we recommend:

@lisp
(global-set-key (kbd "C-x g") 'magit-status)
@end lisp

Most Magit commands are commonly invoked from the status buffer.  It
can be considered the primary interface for interacting with Git using
Magit.  Many other Magit buffers may exist at a given time, but they
are often created from this buffer.

Depending on what state your repository is in, this buffer may contain
sections titled "Staged changes", "Unstaged changes", "Unmerged into
origin/master", "Unpushed to origin/master", and many others.

Since we are starting from a safe state, which you can easily return
to (by doing a @code{git reset --hard PRE-MAGIT-STATE}), there currently are
not staged or unstaged changes.  Edit some files and save the changes.
Then go back to the status buffer, while at the same time refreshing
it, by typing @code{C-x g}.  (When the status buffer, or any Magit buffer for
that matter, is the current buffer, then you can also use just @code{g} to
refresh it).

Move between sections using @code{p} and @code{n}.  Note that the bodies of some
sections are hidden.  Type @code{TAB} to expand or collapse the section at
point.  You can also use @code{C-tab} to cycle the visibility of the current
section and its children.  Move to a file section inside the section
named "Unstaged changes" and type @code{s} to stage the changes you have made
to that file.  That file now appears under "Staged changes".

Magit can stage and unstage individual hunks, not just complete files.
Move to the file you have just staged, expand it using @code{TAB}, move to
one of the hunks using @code{n}, and unstage just that by typing @code{u}.  Note how
the staging (@code{s}) and unstaging (@code{u}) commands operate on the change at
point.  Many other commands behave the same way.

You can also un-/stage just part of a hunk.  Inside the body of a hunk
section (move there using @code{C-n}), set the mark using @code{C-SPC} and move down
until some added and/or removed lines fall inside the region but not
all of them.  Again type @code{s} to stage.

It is also possible to un-/stage multiple files at once.  Move to a
file section, type @code{C-SPC}, move to the next file using @code{n}, and then @code{s} to
stage both files.  Note that both the mark and point have to be on the
headings of sibling sections for this to work.  If the region looks
like it does in other buffers, then it doesn't select Magit sections
that can be acted on as a unit.

And then of course you want to commit your changes.  Type @code{c}.  This
shows the committing popup buffer featuring various commit variants
and arguments that can be passed to @code{git commit}.  Do not worry about
those for now.  We want to create a "normal" commit, which is done by
typing @code{c} again.

Now two new buffers appear.  One is for writing the commit message,
the other shows a diff with the changes that you are about to
committed.  Write a message and then type @code{C-c C-c} to actually create
the commit.

You probably don't want to push the commit you just created because
you just committed some random changes, but if that is not the case
you could push it by typing @code{P} to bring up the push popup and then @code{p}
to push to a branch with the same name as the local branch onto the
remote configured as the push-remote.  (If the push-remote is not
configured yet, then you would first be prompted for the remote to
push to.)

So far we have mentioned the commit, push, and log popups.  These are
probably among the popups you will be using the most, but many others
exist.  To show a popup that lists all other popups (as well as the
various apply commands and some other fundamental commands), type @code{h}.
Try a few.

The key bindings in that popup correspond to the bindings in Magit
buffers, including but not limited to the status buffer.  So you could
type @code{h d} to bring up the diff popup, but once you remember that "d"
stands for "diff", you would usually do so by just typing @code{d}.  But the
"popup of popups" is useful even once you have memorized all the
bindings, as it can provide easy access to Magit commands from
non-Magit buffers.  You should create a global key binding for this
command too:

@lisp
(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
@end lisp

In the same vein, you might also want to enable @code{global-magit-file-mode}
to get some more Magit key bindings in regular file-visiting buffers
(see @ref{Minor Mode for Buffers Visiting Files}).

It is not necessary that you do so now, but if you stick with Magit,
then it is highly recommended that you read the next section too.

@node Interface Concepts
@chapter Interface Concepts

@menu
* Modes and Buffers::
* Sections::
* Popup Buffers and Prefix Commands::
* Completion and Confirmation::
* Running Git::
@end menu

@node Modes and Buffers
@section Modes and Buffers

Magit provides several major-modes.  For each of these modes there
usually exists only one buffer per repository.  Separate modes and
thus buffers exist for commits, diffs, logs, and some other things.

Besides these special purpose buffers, there also exists an overview
buffer, called the @strong{status buffer}.  Its usually from this buffer that
the user invokes Git commands, or creates or visits other buffers.

In this manual we often speak about "Magit buffers".  By that we mean
buffers whose major-modes derive from @code{magit-mode}.

@table @asis
@kindex M-x magit-toggle-buffer-lock
@cindex magit-toggle-buffer-lock
@item @kbd{M-x magit-toggle-buffer-lock} @tie{}@tie{}@tie{}@tie{}(@code{magit-toggle-buffer-lock})

This command locks the current buffer to its value or if the buffer
is already locked, then it unlocks it.

Locking a buffer to its value prevents it from being reused to
display another value.  The name of a locked buffer contains its
value, which allows telling it apart from other locked buffers and
the unlocked buffer.

Not all Magit buffers can be locked to their values, for example it
wouldn't make sense to lock a status buffer.

There can only be a single unlocked buffer using a certain
major-mode per repository.  So when a buffer is being unlocked and
another unlocked buffer already exists for that mode and repository,
then the former buffer is instead deleted and the latter is
displayed in its place.
@end table

@menu
* Switching Buffers::
* Naming Buffers::
* Quitting Windows::
* Automatic Refreshing of Magit Buffers::
* Automatic Saving of File-Visiting Buffers::
* Automatic Reverting of File-Visiting Buffers::
@end menu

@node Switching Buffers
@subsection Switching Buffers

@defun magit-display-buffer buffer

This function is a wrapper around @code{display-buffer} and is used to
display any Magit buffer.  It displays BUFFER in some window and,
unlike @code{display-buffer}, also selects that window, provided
@code{magit-display-buffer-noselect} is @code{nil}.  It also runs the hooks
mentioned below.
@end defun

@defvar magit-display-buffer-noselect

When this is non-nil, then @code{magit-display-buffer} only displays the
buffer but forgoes also selecting the window.  This variable should
not be set globally, it is only intended to be let-bound, by code
that automatically updates "the other window".  This is used for
example when the revision buffer is updated when you move inside the
log buffer.
@end defvar

@defopt magit-display-buffer-function

The function specified here is called by @code{magit-display-buffer} with
one argument, a buffer, to actually display that buffer.  This
function should call @code{display-buffer} with that buffer as first and a
list of display actions as second argument.

Magit provides several functions, listed below, that are suitable
values for this option.  If you want to use different rules, then a
good way of doing that is to start with a copy of one of these
functions and then adjust it to your needs.

Instead of using a wrapper around @code{display-buffer}, that function
itself can be used here, in which case the display actions have to
be specified by adding them to @code{display-buffer-alist} instead.

To learn about display actions, see @ref{Choosing a Window for Display,,,elisp,}.
@end defopt

@defun magit-display-buffer-traditional buffer

This function is the current default value of the option
@code{magit-display-buffer-function}.  Before that option and this function
were added, the behavior was hard-coded in many places all over the
code base but now all the rules are contained in this one function
(except for the "noselect" special case mentioned above).
@end defun

@defun magit-display-buffer-same-window-except-diff-v1

This function displays most buffers in the currently selected
window.  If a buffer's mode derives from @code{magit-diff-mode} or
@code{magit-process-mode}, it is displayed in another window.
@end defun

@defun magit-display-buffer-fullframe-status-v1

This function fills the entire frame when displaying a status
buffer.  Otherwise, it behaves like
@code{magit-display-buffer-traditional}.
@end defun

@defun magit-display-buffer-fullframe-status-topleft-v1

This function fills the entire frame when displaying a status
buffer.  It behaves like @code{magit-display-buffer-fullframe-status-v1}
except that it displays buffers that derive from @code{magit-diff-mode}
or @code{magit-process-mode} to the top or left of the current buffer
rather than to the bottom or right.  As a result, Magit buffers tend
to pop up on the same side as they would if
@code{magit-display-buffer-traditional} were in use.
@end defun

@defun magit-display-buffer-fullcolumn-most-v1

This function displays most buffers so that they fill the entire
height of the frame.  However, the buffer is displayed in another
window if 1) the buffer's mode derives from @code{magit-process-mode},
or 2) the buffer's mode derives from @code{magit-diff-mode}, provided
that the mode of the current buffer derives from @code{magit-log-mode} or
@code{magit-cherry-mode}.
@end defun

@defopt magit-pre-display-buffer-hook

This hook is run by @code{magit-display-buffer} before displaying the
buffer.
@end defopt

@defun magit-save-window-configuration

This function saves the current window configuration.  Later when
the buffer is buried, it may be restored by
@code{magit-restore-window-configuration}.
@end defun

@defopt magit-post-display-buffer-hook

This hook is run by @code{magit-display-buffer} after displaying the
buffer.
@end defopt

@defun magit-maybe-set-dedicated

This function remembers if a new window had to be created to display
the buffer, or whether an existing window was reused.  This
information is later used by @code{magit-mode-quit-window}, to determine
whether the window should be deleted when its last Magit buffer is
buried.
@end defun

@node Naming Buffers
@subsection Naming Buffers

@defopt magit-generate-buffer-name-function

The function used to generate the names of Magit buffers.

Such a function should take the options @code{magit-uniquify-buffer-names}
as well as @code{magit-buffer-name-format} into account.  If it doesn't,
then should be clearly stated in the doc-string.  And if it supports
%-sequences beyond those mentioned in the doc-string of the option
@code{magit-buffer-name-format}, then its own doc-string should describe
the additions.
@end defopt

@defun magit-generate-buffer-name-default-function mode

This function returns a buffer name suitable for a buffer whose
major-mode is MODE and which shows information about the repository
in which @code{default-directory} is located.

This function uses @code{magit-buffer-name-format} and supporting all of
the %-sequences mentioned the documentation of that option.  It also
respects the option @code{magit-uniquify-buffer-names}.
@end defun

@defopt magit-buffer-name-format

The format string used to name Magit buffers.

At least the following %-sequences are supported:

@itemize
@item
@code{%m}

The name of the major-mode, but with the @code{-mode} suffix removed.


@item
@code{%M}

Like @code{%m} but abbreviate @code{magit-status-mode} as @code{magit}.


@item
@code{%v}

The value the buffer is locked to, in parentheses, or an empty
string if the buffer is not locked to a value.


@item
@code{%V}

Like @code{%v}, but the string is prefixed with a space, unless it is an
empty string.


@item
@code{%t}

The top-level directory of the working tree of the repository, or
if @code{magit-uniquify-buffer-names} is non-nil an abbreviation of that.
@end itemize
The value should always contain either @code{%m} or @code{%M}, @code{%v} or @code{%V}, and @code{%t}.
If @code{magit-uniquify-buffer-names} is non-nil, then the value must end
with @code{%t}.
@end defopt

@defopt magit-uniquify-buffer-names

This option controls whether the names of Magit buffers are
uniquified.  If the names are not being uniquified, then they
contain the full path of the top-level of the working tree of the
corresponding repository.  If they are being uniquified, then they
end with the basename of the top-level, or if that would conflict
with the name used for other buffers, then the names of all these
buffers are adjusted until they no longer conflict.

This is done using the @code{uniquify} package; customize its options to
control how buffer names are uniquified.
@end defopt

@node Quitting Windows
@subsection Quitting Windows

@table @asis
@kindex q
@cindex magit-mode-bury-buffer
@item @kbd{q} @tie{}@tie{}@tie{}@tie{}(@code{magit-mode-bury-buffer})

This command buries the current Magit buffer.  With a prefix
argument, it instead kills the buffer.

@end table

@defopt magit-bury-buffer-function

The function used to actually bury or kill the current buffer.

@code{magit-mode-bury-buffer} calls this function with one argument.  If
the argument is non-nil, then the function has to kill the current
buffer.  Otherwise it has to bury it alive.  The default value
currently is @code{magit-restore-window-configuration}.
@end defopt

@defun magit-restore-window-configuration kill-buffer

Bury or kill the current buffer using @code{quit-window}, which is called
with KILL-BUFFER as first and the selected window as second
argument.

Then restore the window configuration that existed right before the
current buffer was displayed in the selected frame.  Unfortunately
that also means that point gets adjusted in all the buffers, which
are being displayed in the selected frame.
@end defun

@defun magit-mode-quit-window kill-buffer

Bury or kill the current buffer using @code{quit-window}, which is called
with KILL-BUFFER as first and the selected window as second
argument.

Then, if the window was originally created to display a Magit buffer
and the buried buffer was the last remaining Magit buffer that was
ever displayed in the window, then that is deleted.
@end defun

@node Automatic Refreshing of Magit Buffers
@subsection Automatic Refreshing of Magit Buffers

After running a command which may change the state of the current
repository, the current Magit buffer and the corresponding status
buffer are refreshed.  The status buffer may optionally be
automatically refreshed whenever a buffer is saved to a file inside
the respective repository.

Automatically refreshing Magit buffers ensures that the displayed
information is up-to-date most of the time but can lead to a
noticeable delay in big repositories.  Other Magit buffers are not
refreshed to keep the delay to a minimum and also because doing so can
sometimes be undesirable.

Buffers can also be refreshed explicitly, which is useful in buffers
that weren't current during the last refresh and after changes were
made to the repository outside of Magit.

@table @asis
@kindex g
@cindex magit-refresh
@item @kbd{g} @tie{}@tie{}@tie{}@tie{}(@code{magit-refresh})

This command refreshes the current buffer if its major mode derives
from @code{magit-mode} as well as the corresponding status buffer.

If the option @code{magit-revert-buffers} calls for it, then it also
reverts all unmodified buffers that visit files being tracked in the
current repository.

@kindex G
@cindex magit-refresh-all
@item @kbd{G} @tie{}@tie{}@tie{}@tie{}(@code{magit-refresh-all})

This command refreshes all Magit buffers belonging to the current
repository and also reverts all unmodified buffers that visit files
being tracked in the current repository.

The file-visiting buffers are always reverted, even if
@code{magit-revert-buffers} is nil.

@end table

@defopt magit-refresh-buffer-hook

This hook is run in each Magit buffer that was refreshed during the
current refresh - normally the current buffer and the status buffer.
@end defopt

@defopt magit-refresh-status-buffer

When this option is non-nil, then the status buffer is automatically
refreshed after running git for side-effects, in addition to the
current Magit buffer, which is always refreshed automatically.

Only set this to nil after exhausting all other options to improve
performance.
@end defopt

@defun magit-after-save-refresh-status

This function is intended to be added to @code{after-save-hook}.  After
doing that the corresponding status buffer is refreshed whenever a
buffer is saved to a file inside a repository.

Note that refreshing a Magit buffer is done by re-creating its
contents from scratch, which can be slow in large repositories.  If
you are not satisfied with Magit's performance, then you should
obviously not add this function to that hook.
@end defun

@node Automatic Saving of File-Visiting Buffers
@subsection Automatic Saving of File-Visiting Buffers

File-visiting buffers are by default saved at certain points in time.
This doesn't guarantee that Magit buffers are always up-to-date, but,
provided one only edits files by editing them in Emacs and uses only
Magit to interact with Git, one can be fairly confident.  When in
doubt or after outside changes, type @code{g} (@code{magit-refresh}) to save and
refresh explicitly.

@defopt magit-save-repository-buffers

This option controls whether file-visiting buffers are saved before
certain events.

If this is non-nil then all modified file-visiting buffers belonging
to the current repository may be saved before running commands,
before creating new Magit buffers, and before explicitly refreshing
such buffers.  If this is @code{dontask} then this is done without user
intervention.  If it is @code{t} then the user has to confirm each save.
@end defopt

@node Automatic Reverting of File-Visiting Buffers
@subsection Automatic Reverting of File-Visiting Buffers

By default Magit automatically reverts buffers that are visiting files
that are being tracked in a Git repository, after they have changed on
disk.  When using Magit one often changes files on disk by running
git, i.e. "outside Emacs", making this a rather important feature.

For example, if you discard a change in the status buffer, then that
is done by running @code{git apply --reverse ...}, and Emacs considers the
file to have "changed on disk".  If Magit did not automatically revert
the buffer, then you would have to type @code{M-x revert-buffer RET RET} in
the visiting buffer before you could continue making changes.

@defopt magit-auto-revert-mode

When this mode is enabled, then buffers that visit tracked files,
are automatically reverted after the visited files changed on disk.
@end defopt

@defopt global-auto-revert-mode

When this mode is enabled, then any file-visiting buffer is
automatically reverted after the visited file changed on disk.

If you like buffers that visit tracked files to be automatically
reverted, then you might also like any buffer to be reverted, not
just those visiting tracked files.  If that is the case, then enable
this mode @emph{instead of} @code{magit-auto-revert-mode}.
@end defopt

@defopt magit-auto-revert-immediately

This option controls whether Magit reverts buffers immediately.

If this is non-nil and either @code{global-auto-revert-mode} or
@code{magit-auto-revert-mode} is enabled, then Magit immediately reverts
buffers by explicitly calling @code{auto-revert-buffers} after running git
for side-effects.

If @code{auto-revert-use-notify} is non-nil (and file notifications are
actually supported), then @code{magit-auto-revert-immediately} does not
have to be non-nil, because the reverts happen immediately anyway.

If @code{magit-auto-revert-immediately} and @code{auto-revert-use-notify} are both
@code{nil}, then reverts happen after @code{auto-revert-interval} seconds of user
inactivity.  That is not desirable.
@end defopt

@defopt auto-revert-use-notify

This option controls whether file notification functions should be
used.  Note that this variable unfortunately defaults to @code{t} even on
systems on which file notifications cannot be used.
@end defopt

@defopt magit-auto-revert-tracked-only

This option controls whether @code{magit-auto-revert-mode} only reverts
tracked files or all files that are located inside Git repositories,
including untracked files and files located inside Git's control
directory.
@end defopt

@cindex auto-revert-mode
@deffn Command auto-revert-mode

The global mode @code{magit-auto-revert-mode} works by turning on this
local mode in the appropriate buffers (but @code{global-auto-revert-mode}
is implemented differently).  You can also turn it on or off
manually, which might be necessary if Magit does not notice that a
previously untracked file now is being tracked or vice-versa.
@end deffn

@defopt auto-revert-stop-on-user-input

This option controls whether the arrival of user input suspends the
automatic reverts for @code{auto-revert-interval} seconds.
@end defopt

@defopt auto-revert-interval

This option controls for how many seconds Emacs waits before
resuming suspended reverts.
@end defopt

@defopt auto-revert-buffer-list-filter

This option specifies an additional filter used by
@code{auto-revert-buffers} to determine whether a buffer should be reverted
or not.

This option is provided by @code{magit}, which also redefines
@code{auto-revert-buffers} to respect it.  Magit users who do not turn on
the local mode @code{auto-revert-mode} themselves, are best served by
setting the value to @code{magit-auto-revert-repository-buffers-p}.

However the default is nil, to not disturb users who do use the
local mode directly.  If you experience delays when running Magit
commands, then you should consider using one of the predicates
provided by Magit - especially if you also use Tramp.

Users who do turn on @code{auto-revert-mode} in buffers in which Magit
doesn't do that for them, should likely not use any filter.  Users
who turn on @code{global-auto-revert-mode}, do not have to worry about this
option, because it is disregarded if the global mode is enabled.
@end defopt

@defopt auto-revert-verbose

This option controls whether Emacs reports when a buffer has been
reverted.
@end defopt

The options with the @code{auto-revert-} prefix are located in the Custom
group named @code{auto-revert}.  The other, magit-specific, options are
located in the @code{magit} group.

@menu
* Risk of Reverting Automatically::
@end menu

@node Risk of Reverting Automatically
@unnumberedsubsubsec Risk of Reverting Automatically

For the vast majority users automatically reverting file-visiting
buffers after they have changed on disk is harmless.

If a buffer is modified (i.e. it contains changes that haven't been
saved yet), then Emacs would refuse to automatically revert it.  If
you save a previously modified buffer, then that results in what is
seen by Git as an uncommitted change.  Git would then refuse to carry
out any commands that would cause these changes to be lost.  In other
words, if there is anything that could be lost, then either Git or
Emacs would refuse to discard the changes.

However if you do use file-visiting buffers as a sort of ad hoc
"staging area", then the automatic reverts could potentially cause
data loss.  So far I have only heard from one user who uses such a
workflow.

An example: You visit some file in a buffer, edit it, and save the
changes.  Then, outside of Emacs (or at least not using Magit or by
saving the buffer) you change the file on disk again.  At this point
the buffer is the only place where the intermediate version still
exists.  You have saved the changes to disk, but that has since been
overwritten.  Meanwhile Emacs considers the buffer to be unmodified
(because you have not made any changes to it since you last saved it
to the visited file) and therefore would not object to it being
automatically reverted.  At this point an Auto-Revert mode would kick
in.  It would check whether the buffer is modified and since that is
not the case it would revert it.  The intermediate version would be
lost.  (Actually you could still get it back using the @code{undo} command.)

If your workflow depends on Emacs preserving the intermediate version
in the buffer, then you have to disable all Auto-Revert modes.  But
please consider that such a workflow would be dangerous even without
using an Auto-Revert mode, and should therefore be avoided.  If Emacs
crashed or if you quit Emacs by mistake, then you would also lose the
buffer content.  There would be no autosave file still containing the
intermediate version (because that was deleted when you saved the
buffer) and you would not be asked whether you want to save the buffer
(because it isn't modified).

@node Sections
@section Sections

Magit buffers are organized into nested sections, which can be
collapsed and expanded, similar to how sections are handled in Org
mode.  Each section also has a type, and some sections also have a
value.  For each section type there can also be a local keymap, shared
by all sections of that type.

Taking advantage of the section value and type, many commands operate on
the current section, or when the region is active and selects sections
of the same type, all of the selected sections.  Commands that only
make sense for a particular section type (as opposed to just behaving
differently depending on the type) are usually bound in section type
keymaps.

@menu
* Section Movement::
* Section Visibility::
* Section Hooks::
* Section Types and Values::
* Section Options::
@end menu

@node Section Movement
@subsection Section Movement

To move within a section use the usual keys (@code{C-p}, @code{C-n}, @code{C-b}, @code{C-f} etc),
whose global bindings are not shadowed.  To move to another section use
the following commands.

@table @asis
@kindex p
@cindex magit-section-backward
@item @kbd{p} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-backward})

When not at the beginning of a section, then move to the beginning
of the current section.  At the beginning of a section, instead move
to the beginning of the previous visible section.

@kindex n
@cindex magit-section-forward
@item @kbd{n} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-forward})

Move to the beginning of the next visible section.

@kindex M-p
@cindex magit-section-backward-siblings
@item @kbd{M-p} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-backward-siblings})

Move to the beginning of the previous sibling section.  If there is
no previous sibling section, then move to the parent section
instead.

@kindex M-n
@cindex magit-section-forward-siblings
@item @kbd{M-n} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-forward-siblings})

Move to the beginning of the next sibling section.  If there is no
next sibling section, then move to the parent section instead.

@kindex ^
@cindex magit-section-up
@item @kbd{^} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-up})

Move to the beginning of the parent of the current section.
@end table

The above commands all call the hook @code{magit-section-movement-hook}.
And, except for the second, the below functions are all members of
that hook's default value.

@defvar magit-section-movement-hook

This hook is run by all of the above movement commands, after
arriving at the destination.
@end defvar

@defun magit-hunk-set-window-start

This hook function ensures that the beginning of the current section
is visible, provided it is a @code{hunk} section.  Otherwise, it does
nothing.
@end defun

@defun magit-section-set-window-start

This hook function ensures that the beginning of the current section
is visible, regardless of the section's type.  If you add this to
@code{magit-section-movement-hook}, then you must remove the hunk-only
variant in turn.
@end defun

@defun magit-log-maybe-show-more-commits

This hook function only has an effect in log buffers, and @code{point} is
on the "show more" section.  If that is the case, then it doubles
the number of commits that are being shown.
@end defun

@defun magit-log-maybe-update-revision-buffer

When moving inside a log buffer, then this function updates the
revision buffer, provided it is already being displayed in another
window of the same frame.
@end defun

@defun magit-log-maybe-update-blob-buffer

When moving inside a log buffer and another window of the same frame
displays a blob buffer, then this function instead displays the blob
buffer for the commit at point in that window.
@end defun

@defun magit-status-maybe-update-revision-buffer

When moving inside a status buffer, then this function updates the
revision buffer, provided it is already being displayed in another
window of the same frame.
@end defun

@defun magit-status-maybe-update-blob-buffer

When moving inside a status buffer and another window of the same
frame displays a blob buffer, then this function instead displays
the blob buffer for the commit at point in that window.
@end defun

@defopt magit-update-other-window-delay

Delay before automatically updating the other window.

When moving around in certain buffers certain other buffers, which
are being displayed in another window, may optionally be updated to
display information about the section at point.

When holding down a key to move by more than just one section, then
that would update that buffer for each section on the way.  To
prevent that, updating the revision buffer is delayed, and this
option controls for how long.  For optimal experience you might have
to adjust this delay and/or the keyboard repeat rate and delay of
your graphical environment or operating system.
@end defopt

@node Section Visibility
@subsection Section Visibility

Magit provides many commands for changing the visibility of sections,
but all you need to get started are the next two.

@table @asis
@kindex TAB
@cindex magit-section-toggle
@item @kbd{TAB} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-toggle})

Toggle the visibility of the body of the current section.

@kindex C-<tab>
@cindex magit-section-cycle
@item @kbd{C-<tab>} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-cycle})

Cycle the visibility of current section and its children.

@kindex M-<tab>
@cindex magit-section-cycle-diffs
@item @kbd{M-<tab>} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-cycle-diffs})

Cycle the visibility of diff-related sections in the current buffer.

@kindex S-<tab>
@cindex magit-section-cycle-global
@item @kbd{S-<tab>} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-cycle-global})

Cycle the visibility of all sections in the current buffer.

@kindex 1
@cindex magit-section-show-level-1
@item @kbd{1} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-1})
@kindex 2
@cindex magit-section-show-level-2
@item @kbd{2} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-2})
@kindex 3
@cindex magit-section-show-level-3
@item @kbd{3} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-3})
@kindex 4
@cindex magit-section-show-level-4
@item @kbd{4} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-4})

Show sections surrounding the current section up to level N.

@kindex M-1
@cindex magit-section-show-level-1-all
@item @kbd{M-1} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-1-all})
@kindex M-2
@cindex magit-section-show-level-2-all
@item @kbd{M-2} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-2-all})
@kindex M-3
@cindex magit-section-show-level-3-all
@item @kbd{M-3} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-3-all})
@kindex M-4
@cindex magit-section-show-level-4-all
@item @kbd{M-4} @tie{}@tie{}@tie{}@tie{}(@code{magit-section-show-level-4-all})

Show all sections up to level N.
@end table

Some functions, which are used to implement the above commands, are
also exposed as commands themselves.  By default no keys are bound to
these commands, as they are generally perceived to be much less
useful.  But your mileage may vary.

@cindex magit-section-show
@deffn Command magit-section-show

Show the body of the current section.
@end deffn

@cindex magit-section-hide
@deffn Command magit-section-hide

Hide the body of the current section.
@end deffn

@cindex magit-section-show-headings
@deffn Command magit-section-show-headings

Recursively show headings of children of the current section.  Only
show the headings.  Previously shown text-only bodies are hidden.
@end deffn

@cindex magit-section-show-children
@deffn Command magit-section-show-children

Recursively show the bodies of children of the current section.
With a prefix argument show children down to the level of the
current section, and hide deeper children.
@end deffn

@cindex magit-section-hide-children
@deffn Command magit-section-hide-children

Recursively hide the bodies of children of the current section.
@end deffn

@cindex magit-section-toggle-children
@deffn Command magit-section-toggle-children

Toggle visibility of bodies of children of the current section.
@end deffn

When a buffer is first created then some sections are shown expanded
while others are not.  This is hard coded.  When a buffer is refreshed
then the previous visibility is preserved. The initial visibility of
certain sections can also be overwritten using the hook
@code{magit-section-set-visibility-hook}.

@defvar magit-section-set-visibility-hook

This hook is run when first creating a buffer and also when
refreshing an existing buffer, and is used to determine the
visibility of the section currently being inserted.

Each function is called with one argument, the section being
inserted.  It should return @code{hide} or @code{show}, or to leave the visibility
undefined @code{nil}.  If no function decides on the visibility and the
buffer is being refreshed, then the visibility is preserved; or if
the buffer is being created, then the hard coded default is used.

Usually this should only be used to set the initial visibility but
not during refreshes.  If @code{magit-insert-section--oldroot} is non-nil,
then the buffer is being refreshed and these functions should
immediately return @code{nil}.
@end defvar

@node Section Hooks
@subsection Section Hooks

Which sections are inserted into certain buffers is controlled with
hooks.  This includes the status and the refs buffers.  For other
buffers, e.g. log, diff, and revision buffers, this is not possible.

For buffers whose sections can be customized by the user, a hook
variable called @code{magit-TYPE-sections-hook} exists.  This hook should be
changed using @code{magit-add-section-hook}.  Avoid using @code{add-hooks} or the
Custom interface.

The various available section hook variables are described later in
this manual along with the appropriate "section inserter functions".

@defun magit-add-section-hook hook function &optional at append local

Add the function FUNCTION to the value of section hook HOOK.

Add FUNCTION at the beginning of the hook list unless optional
APPEND is non-nil, in which case FUNCTION is added at the end.  If
FUNCTION already is a member then move it to the new location.

If optional AT is non-nil and a member of the hook list, then add
FUNCTION next to that instead.  Add before or after AT, or replace
AT with FUNCTION depending on APPEND.  If APPEND is the symbol
@code{replace}, then replace AT with FUNCTION.  For any other non-nil value
place FUNCTION right after AT.  If nil, then place FUNCTION right
before AT.  If FUNCTION already is a member of the list but AT is
not, then leave FUNCTION where ever it already is.

If optional LOCAL is non-nil, then modify the hook's buffer-local
value rather than its global value.  This makes the hook local by
copying the default value.  That copy is then modified.

HOOK should be a symbol.  If HOOK is void, it is first set to nil.
HOOK's value must not be a single hook function.  FUNCTION should
be a function that takes no arguments and inserts one or multiple
sections at point, moving point forward.  FUNCTION may choose not
to insert its section(s), when doing so would not make sense.  It
should not be abused for other side-effects.
@end defun

To remove a function from a section hook, use @code{remove-hook}.

@node Section Types and Values
@subsection Section Types and Values

Each section has a type, for example @code{hunk}, @code{file}, and @code{commit}.
Instances of certain section types also have a value.  The value of a
section of type @code{file}, for example, is a file name.

Users usually do not have to worry about a section's type and value,
but knowing them can be handy at times.

@table @asis
@kindex M-x magit-describe-section
@cindex magit-describe-section
@item @kbd{M-x magit-describe-section} @tie{}@tie{}@tie{}@tie{}(@code{magit-describe-section})

Show information about the section at point in the echo area,
as "VALUE [TYPE PARENT-TYPE@dots{}] BEGINNING-END".
@end table

Many commands behave differently depending on the type of the section
at point and/or somehow consume the value of that section.  But that
is only one of the reasons why the same key may do something different,
depending on what section is current.

Additionally for each section type a keymap @strong{might} be defined, named
@code{magit-TYPE-section-map}.  That keymap is used as text property keymap
of all text belonging to any section of the respective type.  If such
a map does not exist for a certain type, then you can define it
yourself, and it will automatically be used.

@node Section Options
@subsection Section Options

This section describes options that have an effect on more than just a
certain type of sections.  As you can see there are not many of those.

@defopt magit-section-show-child-count

Whether to append the number of children to section headings.  This
only affects sections that could benefit from this information.
@end defopt

@node Popup Buffers and Prefix Commands
@section Popup Buffers and Prefix Commands

Many Magit commands are implemented using @strong{popup buffers}.  First the
user invokes a @strong{popup} or @strong{prefix} command, which causes a popup buffer
with the available @strong{infix} arguments and @strong{suffix} commands to be
displayed.  The user then optionally toggles/sets some arguments and
finally invokes one of the suffix commands.

This is implemented in the library @code{magit-popup}.  Earlier releases used
the library @code{magit-key-mode}.  A future release will switch to a
yet-to-be-written successor, which will likely be named @code{transient}.

Because @code{magit-popup} can also be used by other packages without having
to depend on all of Magit, it is documented in its own manual.  See
@ref{Top,,,magit-popup,}.

@table @asis
@kindex C-c C-c
@cindex magit-dispatch-popup
@item @kbd{C-c C-c} @tie{}@tie{}@tie{}@tie{}(@code{magit-dispatch-popup})

This popup command shows a buffer featuring all other Magit popup
commands as well as some other commands that are not popup commands
themselves.
@end table

This command is also, or especially, useful outside Magit buffers, so
you should setup a global binding:

@lisp
(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
@end lisp

Most popups set their initial arguments according to the corresponding
@code{magit-*-arguments} variable.  Two popups, the log and diff popups
(see @ref{Logging} and @ref{Diffing}), may behave a bit differently, depending
on the value of @code{magit-use-sticky-arguments}.

@defopt magit-use-sticky-arguments

This option controls how diff and log commands reuse arguments from
existing buffers.

When @code{t} (the default value), the log or diff popup reuses the
arguments from the current repository's log or diff buffer,
respectively.  When no log or diff buffer exists for the current
repository, these popups use the default value of
@code{magit-log-arguments} or @code{magit-diff-arguments}.

When @code{current}, log and diff popups will only reuse the arguments if
the current buffer is derived from @code{magit-log-mode} or
@code{magit-diff-mode}, respectively.

When @code{nil}, the default value of @code{magit-log-arguments} or
@code{magit-diff-arguments} is always used.
@end defopt

@node Completion and Confirmation
@section Completion and Confirmation

Many commands read a value from the user.  By default this is done
using the built-in function @code{completing-read}, but Magit can instead use
another completion framework.

@defopt magit-completing-read-function

The value of this variable is the function used to perform
completion.  Because functions @emph{intended} to replace @code{completing-read}
often are not fully compatible drop-in replacements, and also
because Magit expects them to add the default choice to the prompt
themselves, such functions should not be used directly.  Instead a
wrapper function has to be used.
@end defopt

Currently only the real @code{completing-read} and @uref{http://www.emacswiki.org/emacs/InteractivelyDoThings, Ido} are fully supported.
More frameworks will be supported in the future.

@defun magit-builtin-completing-read prompt choices &optional predicate require-match initial-input hist def

Perform completion using @code{completion-read}.
@end defun

@defun magit-ido-completing-read prompt choices &optional predicate require-match initial-input hist def

Perform completion using @code{ido-completing-read+} from the package by
the same name (which you have to explicitly install).  Ido itself
comes with a supposed drop-in replacement @code{ido-completing-read}, but
that has too many deficits to serve our needs.
@end defun

@defopt magit-list-refs-sortby

For many commands that read a ref or refs from the user, the value
of this option can be used to control the order of the refs.  Valid
values include any key accepted by the @code{--sort} flag of @code{git
  for-each-ref}.  By default, refs are sorted alphabetically by their
full name (e.g., "refs/heads/master").
@end defopt

By default many commands that could potentially lead to data loss have
to be confirmed.  This includes many very common commands, so this
can become annoying quickly.  Many of these actions can be undone,
provided @code{magit-wip-before-change-mode} is turned on (which it is not by
default, due to performance concerns).

@defopt magit-no-confirm

The value of this option is a list of symbols, representing commands
which do not have to be confirmed by the user before being carried
out.

When the global mode @code{magit-wip-before-change-mode} is enabled then
many commands can be undone.  If that mode is enabled then adding
@code{safe-with-wip} to this list has the same effect as adding @code{discard},
@code{reverse}, @code{stage-all-changes}, and @code{unstage-all-changes}.

@lisp
(add-to-list 'magit-no-confirm 'safe-with-wip)
@end lisp

For a list of all symbols that can be added to the value of this
variable, see the doc-string.
@end defopt

Note that there are commands that ignore this option and always
require confirmation, or which can be told not to do so using another
dedicated option.  Also most commands, when acting on multiple sections
at once always, require confirmation, even when they do respect this
option when acting on a single section.

@node Running Git
@section Running Git

@menu
* Viewing Git Output::
* Running Git Manually::
* Git Executable::
* Global Git Arguments::
@end menu

@node Viewing Git Output
@subsection Viewing Git Output

Magit runs Git either for side-effects (e.g. when pushing) or to get
some value (e.g. the name of the current branch).  When Git is run for
side-effects then the output goes into a per-repository log buffer,
which can be consulted when things don't go as expected.

@table @asis
@kindex $
@cindex magit-process
@item @kbd{$} @tie{}@tie{}@tie{}@tie{}(@code{magit-process})

This commands displays the process buffer for the current
repository.
@end table

Inside that buffer, the usual key bindings for navigating and showing
sections are available.  There is one additional command.

@table @asis
@kindex k
@cindex magit-process-kill
@item @kbd{k} @tie{}@tie{}@tie{}@tie{}(@code{magit-process-kill})

This command kills the process represented by the section at point.

@end table

@defopt magit-git-debug

When this is non-nil then the output of all calls to git are logged
in the process buffer.  This is useful when debugging, otherwise it
just negatively affects performance.
@end defopt

@node Running Git Manually
@subsection Running Git Manually

While Magit provides many Emacs commands to interact with Git, it does
not cover everything.  In those cases your existing Git knowledge will
come in handy.  Magit provides some commands for running arbitrary Git
commands by typing them into the minibuffer, instead of having to
switch to a shell.

@table @asis
@kindex !
@cindex magit-run-popup
@item @kbd{!} @tie{}@tie{}@tie{}@tie{}(@code{magit-run-popup})

Shows the popup buffer featuring the below suffix commands.

@kindex ! !
@cindex magit-git-command-topdir
@item @kbd{! !} @tie{}@tie{}@tie{}@tie{}(@code{magit-git-command-topdir})

This command reads a command from the user and executes it in the
top-level directory of the current working tree.

The string "git " is used as initial input when prompting the user
for the command.  It can be removed to run another command.

@kindex ! p
@cindex magit-git-command
@item @kbd{! p} @tie{}@tie{}@tie{}@tie{}(@code{magit-git-command})

This command reads a command from the user and executes it in
@code{default-directory}.  With a prefix argument the command is executed
in the top-level directory of the current working tree instead.

The string "git " is used as initial input when prompting the user
for the command.  It can be removed to run another command.

@kindex ! s
@cindex magit-shell-command-topdir
@item @kbd{! s} @tie{}@tie{}@tie{}@tie{}(@code{magit-shell-command-topdir})

This command reads a command from the user and executes it in the
top-level directory of the current working tree.

@kindex ! S
@cindex magit-shell-command
@item @kbd{! S} @tie{}@tie{}@tie{}@tie{}(@code{magit-shell-command})

This command reads a command from the user and executes it in
@code{default-directory}.  With a prefix argument the command is executed
in the top-level directory of the current working tree instead.

@end table

@defopt magit-shell-command-verbose-prompt

Whether the prompt, used by the the above commands when reading a
shell command, shows the directory in which it will be run.
@end defopt

These suffix commands start external gui tools.

@table @asis
@kindex ! k
@cindex magit-run-gitk
@item @kbd{! k} @tie{}@tie{}@tie{}@tie{}(@code{magit-run-gitk})

This command runs @code{gitk} in the current repository.

@kindex ! a
@cindex magit-run-gitk-all
@item @kbd{! a} @tie{}@tie{}@tie{}@tie{}(@code{magit-run-gitk-all})

This command runs @code{gitk --all} in the current repository.

@kindex ! b
@cindex magit-run-gitk-branches
@item @kbd{! b} @tie{}@tie{}@tie{}@tie{}(@code{magit-run-gitk-branches})

This command runs @code{gitk --branches} in the current repository.

@kindex ! g
@cindex magit-run-git-gui
@item @kbd{! g} @tie{}@tie{}@tie{}@tie{}(@code{magit-run-git-gui})

This command runs @code{git gui} in the current repository.
@end table

@node Git Executable
@subsection Git Executable

Except on MS Windows, Magit defaults to running Git without specifying
the path to the git executable.  Instead the first executable found by
Emacs on @code{exec-path} is used (whose value in turn is set based on the
value of the environment variable @code{$PATH} when Emacs was started).

This has the advantage that it continues to work even when using Tramp
to connect to a remote machine on which the executable is found in a
different place.  The downside is that if you have multiple versions
of Git installed, then you might end up using another version than the
one you think you are using.

@table @asis
@kindex M-x magit-version
@cindex magit-version
@item @kbd{M-x magit-version} @tie{}@tie{}@tie{}@tie{}(@code{magit-version})

This command shows the currently used versions of Magit, Git, and
Emacs in the echo area.  Non-interactively this just returns the
Magit version.
@end table

When the @code{system-type} is @code{windows-nt}, then @code{magit-git-executable} is set
to an absolute path when Magit is first loaded.  This is necessary
because Git on that platform comes with several wrapper scripts for
the actual git binary, which are also placed on @code{$PATH}, and using one
of these wrappers instead of the binary would degrade performance
horribly.

If Magit doesn't find the correct executable then you @strong{can} work
around that by setting @code{magit-git-executable} to an absolute path.
But note that doing so is a kludge.  It is better to make sure the
order in the environment variable @code{$PATH} is correct, and that Emacs
is started with that environment in effect.  The command
@code{magit-debug-git-executable} can be useful to find out where Emacs is
searching for git.  If you have to connect from Windows to a
non-Windows machine, then you must change the value to "git".

@defopt magit-git-executable

The git executable used by Magit, either the full path to the
executable or the string "git" to let Emacs find the executable
itself, using the standard mechanism for doing such things.
@end defopt

@table @asis
@kindex M-x magit-debug-git-executable
@cindex magit-debug-git-executable
@item @kbd{M-x magit-debug-git-executable} @tie{}@tie{}@tie{}@tie{}(@code{magit-debug-git-executable})

Display a buffer with information about @code{magit-git-executable}.
@end table

@node Global Git Arguments
@subsection Global Git Arguments

@defopt magit-git-global-arguments

The arguments set here are used every time the git executable is run
as a subprocess.  They are placed right after the executable itself
and before the git command - as in @code{git HERE... COMMAND REST}.  For
valid arguments see 
@ifinfo
@ref{git,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git">git(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git(1) manpage.
@end iftex

Be careful what you add here, especially if you are using Tramp to
connect to servers with ancient Git versions.  Never remove anything
that is part of the default value, unless you really know what you
are doing.  And think very hard before adding something; it will be
used every time Magit runs Git for any purpose.
@end defopt

@node Inspecting
@chapter Inspecting

The functionality provided by Magit can be roughly divided into three
groups: inspecting existing data, manipulating existing data or adding
new data, and transferring data.  Of course that is a rather crude
distinction that often falls short, but it's more useful than no
distinction at all.  This section is concerned with inspecting data,
the next two with manipulating and transferring it.  Then follows a
section about miscellaneous functionality, which cannot easily be fit
into this distinction.

Of course other distinctions make sense too, e.g. Git's distinction
between porcelain and plumbing commands, which for the most part is
equivalent to Emacs' distinction between interactive commands and
non-interactive functions.  All of the sections mentioned before are
mainly concerned with the porcelain -- Magit's plumbing layer is
described later.

@menu
* Status Buffer::
* Repository List::
* Logging::
* Diffing::
* Ediffing::
* References Buffer::
* Bisecting::
* Visiting Blobs::
* Blaming::
@end menu

@node Status Buffer
@section Status Buffer

While other Magit buffers contain e.g. one particular diff or one
particular log, the status buffer contains the diffs for staged and
unstaged changes, logs for unpushed and unpulled commits, lists of
stashes and untracked files, and information related to the current
branch.

During certain incomplete operations -- for example when a merge
resulted in a conflict -- additional information is displayed that
helps proceeding with or aborting the operation.

The command @code{magit-status} displays the status buffer belonging to the
current repository in another window.  This command is used so often
that it should be bound globally.  We recommend using @code{C-x g}:

@lisp
(global-set-key (kbd "C-x g") 'magit-status)
@end lisp

@table @asis
@kindex C-x g
@cindex magit-status
@item @kbd{C-x g} @tie{}@tie{}@tie{}@tie{}(@code{magit-status})

Show the status of the current Git repository in a buffer.
With a prefix argument prompt for a repository to be shown.
With two prefix arguments prompt for an arbitrary directory.
If that directory isn't the root of an existing repository,
then offer to initialize it as a new repository.

@end table

@defopt magit-repository-directories

List of directories that are or contain Git repositories.  Each
element has the form @code{(DIRECTORY . DEPTH)} or, for backward
compatibility, just DIRECTORY.  DIRECTORY has to be a directory or
a directory file-name, a string.  DEPTH, an integer, specifies the
maximum depth to look for Git repositories.  If it is 0, then only
add DIRECTORY itself.  For elements that are strings, the value of
option @code{magit-repository-directories-depth} specifies the depth.
@end defopt

@defopt magit-repository-directories-depth

The maximum depth to look for Git repositories.  This option is
obsolete and only used for elements of the option
@code{magit-repository-directories} (which see) that don't specify the
depth directly.
@end defopt

@cindex ido-enter-magit-status
@deffn Command ido-enter-magit-status

From an Ido prompt used to open a file, instead drop into
@code{magit-status}.  This is similar to @code{ido-magic-delete-char}, which,
despite its name, usually causes a Dired buffer to be created.

To make this command available, use something like:

@lisp
(add-hook 'ido-setup-hook
          (lambda ()
            (define-key ido-completion-map
              (kbd \"C-x g\") 'ido-enter-magit-status)))
@end lisp

Starting with Emacs 25.1 the Ido keymaps are defined just once
instead of every time Ido is invoked, so now you can modify it
like pretty much every other keymap:

@lisp
(define-key ido-common-completion-map
  (kbd \"C-x g\") 'ido-enter-magit-status)
@end lisp
@end deffn

@menu
* Status Sections::
* Status Header Sections::
* Status Module Sections::
* Status Options::
@end menu

@node Status Sections
@subsection Status Sections

The contents of status buffers is controlled using the hook
@code{magit-status-sections-hook}.  See @ref{Section Hooks} to learn about such
hooks and how to customize them.

@defopt magit-status-sections-hook

Hook run to insert sections into a status buffer.
@end defopt

The first function on that hook by default is
@code{magit-insert-status-headers}; it is described in the next section.
By default the following functions are also members of that hook:

@defun magit-insert-merge-log

Insert section for the on-going merge.  Display the heads that are
being merged.  If no merge is in progress, do nothing.
@end defun

@defun magit-insert-rebase-sequence

Insert section for the on-going rebase sequence.
If no such sequence is in progress, do nothing.
@end defun

@defun magit-insert-am-sequence

Insert section for the on-going patch applying sequence.
If no such sequence is in progress, do nothing.
@end defun

@defun magit-insert-sequencer-sequence

Insert section for the on-going cherry-pick or revert sequence.
If no such sequence is in progress, do nothing.
@end defun

@defun magit-insert-bisect-output

While bisecting, insert section with output from @code{git bisect}.
@end defun

@defun magit-insert-bisect-rest

While bisecting, insert section visualizing the bisect state.
@end defun

@defun magit-insert-bisect-log

While bisecting, insert section logging bisect progress.
@end defun

@defun magit-insert-untracked-files

Maybe insert a list or tree of untracked files.

Do so depending on the value of @code{status.showUntrackedFiles}.  Note
that even if the value is @code{all}, Magit still initially only shows
directories.  But the directory sections can then be expanded using
@code{TAB}.
@end defun

@defun magit-insert-unstaged-changes

Insert section showing unstaged changes.
@end defun

@defun magit-insert-staged-changes

Insert section showing staged changes.
@end defun

@defun magit-insert-stashes &optional ref heading

Insert the @code{stashes} section showing reflog for "refs/stash".
If optional REF is non-nil show reflog for that instead.
If optional HEADING is non-nil use that as section heading
instead of "Stashes:".
@end defun

@defun magit-insert-unpulled-from-upstream

Insert section showing commits that haven't been pulled from the
upstream branch yet.
@end defun

@defun magit-insert-unpulled-from-pushremote

Insert section showing commits that haven't been pulled from the
push-remote branch yet.
@end defun

@defun magit-insert-unpushed-to-upstream

Insert section showing commits that haven't been pushed to the
upstream yet.
@end defun

@defun magit-insert-unpushed-to-pushremote

Insert section showing commits that haven't been pushed to the
push-remote yet.
@end defun

The following functions can also be added to the above hook:

@defun magit-insert-tracked-files

Insert a tree of tracked files.
@end defun

@defun magit-insert-unpulled-or-recent-commits

Insert section showing unpulled or recent commits.
If an upstream is configured for the current branch and it is
ahead of the current branch, then show the missing commits.
Otherwise, show the last @code{magit-log-section-commit-count}
commits.
@end defun

@defun magit-insert-recent-commits

Insert section showing the last @code{magit-log-section-commit-count}
commits.
@end defun

@defopt magit-log-section-commit-count

How many recent commits @code{magit-insert-recent-commits} and
@code{magit-insert-unpulled-or-recent-commits} (provided there are no
unpulled commits) show.
@end defopt

@defun magit-insert-unpulled-cherries

Insert section showing unpulled commits.
Like @code{magit-insert-unpulled-commits} but prefix each commit
that has not been applied yet (i.e. a commit with a patch-id
not shared with any local commit) with "+", and all others
with "-".
@end defun

@defun magit-insert-unpushed-cherries

Insert section showing unpushed commits.
Like @code{magit-insert-unpushed-commits} but prefix each commit
which has not been applied to upstream yet (i.e. a commit with
a patch-id not shared with any upstream commit) with "+" and
all others with "-".
@end defun

See @ref{References Buffer} for some more section inserters, which could be
used here.

@node Status Header Sections
@subsection Status Header Sections

The contents of status buffers is controlled using the hook
@code{magit-status-sections-hook} (see @ref{Status Sections}).

By default @code{magit-insert-status-headers} is the first member of that
hook variable.

@defun magit-insert-status-headers

Insert headers sections appropriate for @code{magit-status-mode} buffers.
The sections are inserted by running the functions on the hook
@code{magit-status-headers-hook}.
@end defun

@defopt magit-status-headers-hook

Hook run to insert headers sections into the status buffer.

This hook is run by @code{magit-insert-status-headers}, which in turn has
to be a member of @code{magit-status-sections-hook} to be used at all.
@end defopt

By default the following functions are members of the above hook:

@defun magit-insert-error-header

Insert a header line showing the message about the Git error that
just occurred.

This function is only aware of the last error that occur when Git
was run for side-effects.  If, for example, an error occurs while
generating a diff, then that error won't be inserted.  Refreshing
the status buffer causes this section to disappear again.
@end defun

@defun magit-insert-diff-filter-header

Insert a header line showing the effective diff filters.
@end defun

@defun magit-insert-head-branch-header

Insert a header line about the current branch or detached @code{HEAD}.
@end defun

@defun magit-insert-upstream-branch-header

Insert a header line about the branch that is usually pulled into
the current branch.
@end defun

@defun magit-insert-push-branch-header

Insert a header line about the branch that the current branch is
usually pushed to.
@end defun

@defun magit-insert-tags-header

Insert a header line about the current and/or next tag, along with the
number of commits between the tag and @code{HEAD}.
@end defun

The following functions can also be added to the above hook:

@defun magit-insert-repo-header

Insert a header line showing the path to the repository top-level.
@end defun

@defun magit-insert-remote-header

Insert a header line about the remote of the current branch.

If no remote is configured for the current branch, then fall back
showing the "origin" remote, or if that does not exist the first
remote in alphabetic order.
@end defun

@defun magit-insert-user-header

Insert a header line about the current user.
@end defun

@node Status Module Sections
@subsection Status Module Sections

The contents of status buffers is controlled using the hook
@code{magit-status-sections-hook} (see @ref{Status Sections}).

By default @code{magit-insert-modules} is @emph{not} a member of that hook
variable.

@defun magit-insert-modules

Insert submodule sections.

Hook @code{magit-module-sections-hook} controls which module sections are
inserted, and option @code{magit-insert-modules-nested} controls whether
they are wrapped in an additional section.
@end defun

@itemize
@item
Option: magit-module-sections-hook

Hook run by @code{magit-insert-modules}.


@item
Option: magit-module-sections-nested

This option controls whether @code{magit-insert-modules} wraps inserted
sections in an additional section.

If this is non-nil, then only a single top-level section is inserted.
If it is nil, then all sections listed in @code{magit-module-sections-hook}
become top-level sections.

@end itemize

@defun magit-insert-modules-overview

Insert sections for all submodules.  For each section insert the
path, the branch, and the output of @code{git describe --tags}.

Press @code{RET} on such a submodule section to show its own status buffer.
Press @code{RET} on the "Modules" section to display a list of submodules
in a separate buffer.  This shows additional information not
displayed in the super-repository's status buffer.
@end defun

@defun magit-insert-modules-unpulled-from-upstream

Insert sections for modules that haven't been pulled from the
upstream yet.  These sections can be expanded to show the respective
commits.
@end defun

@defun magit-insert-modules-unpulled-from-pushremote

Insert sections for modules that haven't been pulled from the
push-remote yet.  These sections can be expanded to show the
respective commits.
@end defun

@defun magit-insert-modules-unpushed-to-upstream

Insert sections for modules that haven't been pushed to the upstream
yet.  These sections can be expanded to show the respective commits.
@end defun

@defun magit-insert-modules-unpushed-to-pushremote

Insert sections for modules that haven't been pushed to the
push-remote yet.  These sections can be expanded to show the
respective commits.
@end defun

@node Status Options
@subsection Status Options

@defopt magit-status-refresh-hook

Hook run after a status buffer has been refreshed.
@end defopt

@defopt magit-status-margin

This option specifies whether the margin is initially shown in
Magit-Status mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@defopt magit-log-section-args

Additional Git arguments used when creating log sections.  Only
@code{--graph}, @code{--decorate}, and @code{--show-signature} are supported.  This
option is only a temporary kludge and will be removed.

Note that due to an issue in Git the use of @code{--graph} is very slow
with long histories, so you probably don't want to add this here.
@end defopt

Also see the proceeding section for more options concerning status
buffers.

@node Repository List
@section Repository List

@cindex magit-list-repositories
@deffn Command magit-list-repositories

This command displays a list of repositories in a separate buffer.

The options @code{magit-repository-directories} and
@code{magit-repository-directories-depth} control which repositories are
displayed.
@end deffn

@defopt magit-repolist-columns

This option controls what columns are displayed by the command
@code{magit-list-repositories} and how they are displayed.

Each element has the form @code{(HEADER WIDTH FORMAT PROPS)}.

HEADER is the string displayed in the header.  WIDTH is the width of
the column.  FORMAT is a function that is called with one argument,
the repository identification (usually its basename), and with
@code{default-directory} bound to the toplevel of its working tree.  It
has to return a string to be inserted or nil.  PROPS is an alist
that supports the keys @code{:right-align} and @code{:pad-right}.
@end defopt

The following functions can be added to the above option:

@defun magit-repolist-column-ident

This function inserts the identification of the repository.  Usually
this is just its basename.
@end defun

@defun magit-repolist-column-path

This function inserts the absolute path of the repository.
@end defun

@defun magit-repolist-column-version

This function inserts a description of the repository's @code{HEAD} revision.
@end defun

@defun magit-repolist-column-unpulled-from-upstream

This function inserts the number of upstream commits not in the
current branch.
@end defun

@defun magit-repolist-column-unpulled-from-pushremote

This function inserts the number of commits in the push branch but
not the current branch.
@end defun

@defun magit-repolist-column-unpushed-to-upstream

This function inserts the number of commits in the current branch
but not its upstream.
@end defun

@defun magit-repolist-column-unpushed-to-pushremote

This function inserts the number of commits in the current branch
but not its push branch.
@end defun

@node Logging
@section Logging

The status buffer contains logs for the unpushed and unpulled commits,
but that obviously isn't enough.  The prefix command @code{magit-log-popup},
on @code{l}, features several suffix commands, which show a specific log in a
separate log buffer.

Like other popups, the log popup also features several arguments that
can be changed before invoking one of the suffix commands.  However,
in the case of the log popup, these arguments may be taken from those
currently in use in the current repository's log buffer, depending on
the value of @code{magit-use-sticky-arguments} (see @ref{Popup Buffers and Prefix Commands}).

For information about the various arguments, see 
@ifinfo
@ref{git-log,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-log">git-log(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-log(1) manpage.
@end iftex

The switch @code{++order=VALUE} is converted to one of @code{--author-date-order},
@code{--date-order}, or @code{--topo-order} before being passed to @code{git log}.

The log popup also features several reflog commands.  See @ref{Reflog}.

@table @asis
@kindex l
@cindex magit-log-popup
@item @kbd{l} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex l l
@cindex magit-log-current
@item @kbd{l l} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-current})

Show log for the current branch.  When @code{HEAD} is detached or with a
prefix argument, show log for one or more revs read from the
minibuffer.

@kindex l o
@cindex magit-log
@item @kbd{l o} @tie{}@tie{}@tie{}@tie{}(@code{magit-log})

Show log for one or more revs read from the minibuffer.  The user
can input any revision or revisions separated by a space, or even
ranges, but only branches, tags, and a representation of the
commit at point are available as completion candidates.

@kindex l h
@cindex magit-log-head
@item @kbd{l h} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-head})

Show log for @code{HEAD}.

@kindex l L
@cindex magit-log-branches
@item @kbd{l L} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-branches})

Show log for all local branches and @code{HEAD}.

@kindex l b
@cindex magit-log-all-branches
@item @kbd{l b} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-all-branches})

Show log for all local and remote branches and @code{HEAD}.

@kindex l a
@cindex magit-log-all
@item @kbd{l a} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-all})

Show log for all references and @code{HEAD}.
@end table


Two additional commands that show the log for the file or blob that
is being visited in the current buffer exists, see @ref{Minor Mode for Buffers Visiting Files}.  The command @code{magit-cherry} also shows a log,
see @ref{Cherries}.

@menu
* Refreshing Logs::
* Log Buffer::
* Log Margin::
* Select from Log::
* Reflog::
* Cherries::
@end menu

@node Refreshing Logs
@subsection Refreshing Logs

The prefix command @code{magit-log-refresh-popup}, on @code{L}, can be used to
change the log arguments used in the current buffer, without changing
which log is shown.  This works in dedicated log buffers, but also in
the status buffer.

@table @asis
@kindex L
@cindex magit-log-refresh-popup
@item @kbd{L} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-refresh-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex L g
@cindex magit-log-refresh
@item @kbd{L g} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-refresh})

This suffix command sets the local log arguments for the current
buffer.

@kindex L s
@cindex magit-log-set-default-arguments
@item @kbd{L s} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-set-default-arguments})

This suffix command sets the default log arguments for buffers of
the same type as that of the current buffer.  Other existing buffers
of the same type are not affected because their local values have
already been initialized.

@kindex L w
@cindex magit-log-save-default-arguments
@item @kbd{L w} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-save-default-arguments})

This suffix command sets the default log arguments for buffers of
the same type as that of the current buffer, and saves the value for
future sessions.  Other existing buffers of the same type are not
affected because their local values have already been initialized.

@kindex L t
@cindex magit-toggle-margin
@item @kbd{L t} @tie{}@tie{}@tie{}@tie{}(@code{magit-toggle-margin})

Show or hide the margin.
@end table

@node Log Buffer
@subsection Log Buffer

@table @asis
@kindex L
@cindex magit-log-refresh-popup
@item @kbd{L} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-refresh-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.  See @ref{Refreshing Logs}.

@kindex q
@cindex magit-log-bury-buffer
@item @kbd{q} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-bury-buffer})

Bury the current buffer or the revision buffer in the same frame.
Like @code{magit-mode-bury-buffer} (which see) but with a negative prefix
argument instead bury the revision buffer, provided it is displayed
in the current frame.

@kindex C-c C-b
@cindex magit-go-backward
@item @kbd{C-c C-b} @tie{}@tie{}@tie{}@tie{}(@code{magit-go-backward})

Move backward in current buffer's history.

@kindex C-c C-f
@cindex magit-go-forward
@item @kbd{C-c C-f} @tie{}@tie{}@tie{}@tie{}(@code{magit-go-forward})

Move forward in current buffer's history.

@kindex C-c C-n
@cindex magit-log-move-to-parent
@item @kbd{C-c C-n} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-move-to-parent})

Move to a parent of the current commit.  By default, this is the
first parent, but a numeric prefix can be used to specify another
parent.

@kindex SPC
@cindex magit-diff-show-or-scroll-up
@item @kbd{SPC} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-show-or-scroll-up})

Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer,
or if that buffer is already being displayed in the current frame
and contains information about that commit or stash, then instead
scroll the buffer up.  If there is no commit or stash at point, then
prompt for a commit.

@kindex DEL
@cindex magit-diff-show-or-scroll-down
@item @kbd{DEL} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-show-or-scroll-down})

Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer,
or if that buffer is already being displayed in the current frame
and contains information about that commit or stash, then instead
scroll the buffer down.  If there is no commit or stash at point,
then prompt for a commit.

@kindex =
@cindex magit-log-toggle-commit-limit
@item @kbd{=} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-toggle-commit-limit})

Toggle the number of commits the current log buffer is limited to.
If the number of commits is currently limited, then remove that
limit.  Otherwise set it to 256.

@kindex +
@cindex magit-log-double-commit-limit
@item @kbd{+} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-double-commit-limit})

Double the number of commits the current log buffer is limited to.

@kindex -
@cindex magit-log-half-commit-limit
@item @kbd{-} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-half-commit-limit})

Half the number of commits the current log buffer is limited to.

@end table

@defopt magit-log-auto-more

Insert more log entries automatically when moving past the last
entry.  Only considered when moving past the last entry with
@code{magit-goto-*-section} commands.
@end defopt

@defopt magit-log-show-refname-after-summary

Whether to show the refnames after the commit summaries.  This is
useful if you use really long branch names.
@end defopt

For a description of @code{magit-log-margin} see @ref{Log Margin}.

@node Log Margin
@subsection Log Margin

In buffers which show one or more logs, it is possible to show
additional information about each commit in the margin.  The options
used to configure the margin are named @code{magit-INFIX-margin}, where INFIX
is the same as in the respective major-mode @code{magit-INFIX-mode}.  In
regular log buffers that would be @code{magit-log-margin}.

@defopt magit-log-margin

This option specifies whether the margin is initially shown in
Magit-Log mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

You can change the STYLE and AUTHOR-WIDTH of all @code{magit-INFIX-margin}
options to the same values by customizing @code{magit-log-margin} @strong{before}
@code{magit} is loaded.  If you do that, then the respective values for the
other options will default to what you have set for that variable.
Likewise if you set INIT in @code{magit-log-margin} to @code{nil}, then that is used
in the default of all other options.  But setting it to @code{t}, i.e.
re-enforcing the default for that option, does not carry to other
options.

@table @asis
@kindex L
@cindex magit-margin-popup
@item @kbd{L} @tie{}@tie{}@tie{}@tie{}(@code{magit-margin-popup})

This prefix command features the following commands for changing the
appearance of the margin.
@end table

In some buffers that support the margin, "L" is bound to
@code{magit-log-refresh-popup}, but that popup features the same commands,
and then some other unrelated commands.

@table @asis
@kindex L L
@cindex magit-toggle-margin
@item @kbd{L L} @tie{}@tie{}@tie{}@tie{}(@code{magit-toggle-margin})

This command shows or hides the margin.

@kindex L l
@cindex magit-cycle-margin-style
@item @kbd{L l} @tie{}@tie{}@tie{}@tie{}(@code{magit-cycle-margin-style})

This command cycles the style used for the margin.

@kindex L d
@cindex magit-toggle-margin-details
@item @kbd{L d} @tie{}@tie{}@tie{}@tie{}(@code{magit-toggle-margin-details})

This command shows or hides details in the margin.
@end table

@node Select from Log
@subsection Select from Log

When the user has to select a recent commit that is reachable from
@code{HEAD}, using regular completion would be inconvenient (because most
humans cannot remember hashes or "HEAD~5", at least not without double
checking).  Instead a log buffer is used to select the commit, which
has the advantage that commits are presented in order and with the
commit message.

Such selection logs are used when selecting the beginning of a rebase
and when selecting the commit to be squashed into.

In addition to the key bindings available in all log buffers, the
following additional key bindings are available in selection log
buffers:

@table @asis
@kindex C-c C-c
@cindex magit-log-select-pick
@item @kbd{C-c C-c} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-select-pick})

Select the commit at point and act on it.  Call
@code{magit-log-select-pick-function} with the selected commit as
argument.

@kindex C-c C-k
@cindex magit-log-select-quit
@item @kbd{C-c C-k} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-select-quit})

Abort selecting a commit, don't act on any commit.

@end table

@defopt magit-log-select-margin

This option specifies whether the margin is initially shown in
Magit-Log-Select mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@node Reflog
@subsection Reflog

Also see 
@ifinfo
@ref{git-reflog,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-reflog">git-reflog(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-reflog(1) manpage.
@end iftex

These reflog commands are available from the log popup.  See @ref{Logging}.

@table @asis
@kindex l r
@cindex magit-reflog-current
@item @kbd{l r} @tie{}@tie{}@tie{}@tie{}(@code{magit-reflog-current})

Display the reflog of the current branch.

@kindex l O
@cindex magit-reflog-other
@item @kbd{l O} @tie{}@tie{}@tie{}@tie{}(@code{magit-reflog-other})

Display the reflog of a branch.

@kindex l H
@cindex magit-reflog-head
@item @kbd{l H} @tie{}@tie{}@tie{}@tie{}(@code{magit-reflog-head})

Display the @code{HEAD} reflog.

@end table

@defopt magit-reflog-margin

This option specifies whether the margin is initially shown in
Magit-Reflog mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@node Cherries
@subsection Cherries

Cherries are commits that haven't been applied upstream (yet), and are
usually visualized using a log.  Each commit is prefixed with @code{-} if it
has an equivalent in the upstream and @code{+} if it does not, i.e. if it is
a cherry.

The command @code{magit-cherry} shows cherries for a single branch, but the
references buffer (see @ref{References Buffer}) can show cherries for
multiple "upstreams" at once.

Also see 
@ifinfo
@ref{git-reflog,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-reflog">git-reflog(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-reflog(1) manpage.
@end iftex

@table @asis
@kindex Y
@cindex magit-cherry
@item @kbd{Y} @tie{}@tie{}@tie{}@tie{}(@code{magit-cherry})

Show commits that are in a certain branch but that have not been
merged in the upstream branch.

@end table

@defopt magit-cherry-margin

This option specifies whether the margin is initially shown in
Magit-Cherry mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@node Diffing
@section Diffing

The status buffer contains diffs for the staged and unstaged commits,
but that obviously isn't enough.  The prefix command @code{magit-diff-popup},
on @code{d}, features several suffix commands, which show a specific diff in
a separate diff buffer.

Like other popups, the diff popup also features several arguments that
can be changed before invoking one of the suffix commands.  However,
in the case of the diff popup, these arguments may be taken from those
currently in use in the current repository's log buffer, depending on
the value of @code{magit-use-sticky-arguments} (see @ref{Popup Buffers and Prefix Commands}).

Also see 
@ifinfo
@ref{git-diff,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-diff">git-diff(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-diff(1) manpage.
@end iftex

@table @asis
@kindex d
@cindex magit-diff-popup
@item @kbd{d} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex d d
@cindex magit-diff-dwim
@item @kbd{d d} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-dwim})

Show changes for the thing at point.

@kindex d r
@cindex magit-diff
@item @kbd{d r} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff})

Show differences between two commits.

RANGE should be a range (A..B or A@dots{}B) but can also be a single
commit.  If one side of the range is omitted, then it defaults to
@code{HEAD}.  If just a commit is given, then changes in the working tree
relative to that commit are shown.

If the region is active, use the revisions on the first and last
line of the region.  With a prefix argument, instead of diffing the
revisions, choose a revision to view changes along, starting at the
common ancestor of both revisions (i.e., use a "@dots{}"  range).

@kindex d w
@cindex magit-diff-working-tree
@item @kbd{d w} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-working-tree})

Show changes between the current working tree and the @code{HEAD} commit.
With a prefix argument show changes between the working tree and a
commit read from the minibuffer.

@kindex d s
@cindex magit-diff-staged
@item @kbd{d s} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-staged})

Show changes between the index and the @code{HEAD} commit.  With a prefix
argument show changes between the index and a commit read from the
minibuffer.

@kindex d u
@cindex magit-diff-unstaged
@item @kbd{d u} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-unstaged})

Show changes between the working tree and the index.

@kindex d p
@cindex magit-diff-paths
@item @kbd{d p} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-paths})

Show changes between any two files on disk.
@end table

All of the above suffix commands update the repository's diff buffer.
The diff popup also features two commands which show differences in
another buffer:

@table @asis
@kindex d c
@cindex magit-show-commit
@item @kbd{d c} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-commit})

Show the commit at point.  If there is no commit at point or with a
prefix argument, prompt for a commit.

@kindex d t
@cindex magit-stash-show
@item @kbd{d t} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-show})

Show all diffs of a stash in a buffer.
@end table

Two additional commands that show the diff for the file or blob that
is being visited in the current buffer exists, see @ref{Minor Mode for Buffers Visiting Files}.

@menu
* Refreshing Diffs::
* Diff Buffer::
* Diff Options::
* Revision Buffer::
@end menu

@node Refreshing Diffs
@subsection Refreshing Diffs

The prefix command @code{magit-diff-refresh-popup}, on @code{D}, can be used to
change the diff arguments used in the current buffer, without changing
which diff is shown.  This works in dedicated diff buffers, but also
in the status buffer.

@table @asis
@kindex D
@cindex magit-diff-refresh-popup
@item @kbd{D} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-refresh-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex D g
@cindex magit-diff-refresh
@item @kbd{D g} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-refresh})

This suffix command sets the local diff arguments for the current
buffer.

@kindex D s
@cindex magit-diff-set-default-arguments
@item @kbd{D s} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-set-default-arguments})

This suffix command sets the default diff arguments for buffers of
the same type as that of the current buffer.  Other existing buffers
of the same type are not affected because their local values have
already been initialized.

@kindex D w
@cindex magit-diff-save-default-arguments
@item @kbd{D w} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-save-default-arguments})

This suffix command sets the default diff arguments for buffers of
the same type as that of the current buffer, and saves the value for
future sessions.  Other existing buffers of the same type are not
affected because their local values have already been initialized.

@kindex D t
@cindex magit-diff-toggle-refine-hunk
@item @kbd{D t} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-toggle-refine-hunk})

This command toggles hunk refinement on or off.

@kindex D r
@cindex magit-diff-switch-range-type
@item @kbd{D r} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-switch-range-type})

This command converts the diff range type from "revA..revB" to
"revB@dots{}revA", or vice versa.

@kindex D f
@cindex magit-diff-flip-revs
@item @kbd{D f} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-flip-revs})

This command swaps revisions in the diff range from "revA..revB"
to "revB..revA", or vice versa.

@kindex D F
@cindex magit-diff-toggle-file-filter
@item @kbd{D F} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-toggle-file-filter})

This command toggles the file restriction of the diffs in the
current buffer, allowing you to quickly switch between viewing all
the changes in the commit and the restricted subset.  As a special
case, when this command is called from a log buffer, it toggles the
file restriction in the repository's revision buffer, which is
useful when you display a revision from a log buffer that is
restricted to a file or files.
@end table

In addition to the above popup, which allows changing any of the
supported arguments, there also exist some commands which change a
particular argument.

@table @asis
@kindex -
@cindex magit-diff-less-context
@item @kbd{-} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-less-context})

This command decreases the context for diff hunks by COUNT lines.

@kindex +
@cindex magit-diff-more-context
@item @kbd{+} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-more-context})

This command increases the context for diff hunks by COUNT lines.

@kindex 0
@cindex magit-diff-default-context
@item @kbd{0} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-default-context})

This command resets the context for diff hunks to the default height.
@end table

The following commands quickly change what diff is being displayed
without having to using one of the diff popups.

@table @asis
@kindex C-c C-d
@cindex magit-diff-while-committing
@item @kbd{C-c C-d} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-while-committing})

While committing, this command shows the changes that are about to
be committed.  While amending, invoking the command again toggles
between showing just the new changes or all the changes that will be
committed.

This binding is available in the diff buffer as well as the commit
message buffer.

@kindex C-c C-b
@cindex magit-go-backward
@item @kbd{C-c C-b} @tie{}@tie{}@tie{}@tie{}(@code{magit-go-backward})

This command moves backward in current buffer's history.

@kindex C-c C-f
@cindex magit-go-forward
@item @kbd{C-c C-f} @tie{}@tie{}@tie{}@tie{}(@code{magit-go-forward})

This command moves forward in current buffer's history.
@end table

@node Diff Buffer
@subsection Diff Buffer

@table @asis
@kindex RET
@cindex magit-diff-visit-file
@item @kbd{RET} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-visit-file})

From a diff, visit the corresponding file at the appropriate position.

If the diff shows changes in the worktree, the index, or @code{HEAD}, then
visit the actual file.  Otherwise, when the diff is about an older
commit or a range, then visit the appropriate blob.

If point is on a removed line, then visit the blob for the first
parent of the commit which removed that line, i.e. the last
commit where that line still existed.  Otherwise visit the blob
for the commit whose changes are being shown.

When the file or blob to be displayed is already being displayed in
another window of the same frame, then just select that window and
adjust point.  Otherwise, or with a prefix argument, display the
buffer in another window.

@end table

@defopt magit-diff-visit-previous-blob

This option controls whether @code{magit-diff-visit-file} may visit the
previous blob.  When this is @code{t} and point is on a removed line in a
diff for a committed change, then @code{magit-diff-visit-file} visits the
blob from the last revision which still had that line.

Currently this is only supported for committed changes, for staged
and unstaged changes @code{magit-diff-visit-file} always visits the file in
the working tree.
@end defopt

@table @asis
@kindex C-<return>
@cindex magit-diff-visit-file-worktree
@item @kbd{C-<return>} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-visit-file-worktree})

From a diff, visit the corresponding file at the appropriate position.

When the file is already being displayed in another window of the
same frame, then just select that window and adjust point.  With
a prefix argument also display in another window.

The actual file in the worktree is visited. The positions in the
hunk headers get less useful the "older" the changes are, and as a
result, jumping to the appropriate position gets less reliable.

Also see @code{magit-diff-visit-file}, which visits the respective blob,
unless the diff shows changes in the worktree, the index, or @code{HEAD}.

@kindex j
@cindex magit-jump-to-diffstat-or-diff
@item @kbd{j} @tie{}@tie{}@tie{}@tie{}(@code{magit-jump-to-diffstat-or-diff})

Jump to the diffstat or diff.  When point is on a file inside the
diffstat section, then jump to the respective diff section.
Otherwise, jump to the diffstat section or a child thereof.

@kindex SPC
@cindex scroll-up
@item @kbd{SPC} @tie{}@tie{}@tie{}@tie{}(@code{scroll-up})

Scroll text upward.

@kindex DEL
@cindex scroll-down
@item @kbd{DEL} @tie{}@tie{}@tie{}@tie{}(@code{scroll-down})

Scroll text downward.
@end table

@node Diff Options
@subsection Diff Options

@defopt magit-diff-refine-hunk

Whether to show word-granularity differences within diff hunks.

@itemize
@item
@code{nil} never show fine differences.

@item
@code{t} show fine differences for the current diff hunk only.

@item
@code{all} show fine differences for all displayed diff hunks.
@end itemize
@end defopt

@defopt magit-diff-paint-whitespace

Specify where to highlight whitespace errors.

See @code{magit-diff-highlight-trailing},
@code{magit-diff-highlight-indentation}.  The symbol @code{t} means in all
diffs, @code{status} means only in the status buffer, and nil means
nowhere.
@end defopt

@defopt magit-diff-highlight-trailing

Whether to highlight whitespace at the end of a line in diffs.  Used
only when @code{magit-diff-paint-whitespace} is non-nil.
@end defopt

@defopt magit-diff-highlight-indentation

Highlight the "wrong" indentation style.  Used only when
@code{magit-diff-paint-whitespace} is non-nil.

The value is a list of cons cells.  The car is a regular expression,
and the cdr is the value that applies to repositories whose
directory matches the regular expression.  If more than one element
matches, then the @strong{last} element in the list applies.  The default
value should therefore come first in the list.

If the value is @code{tabs}, highlight indentation with tabs.  If the value
is an integer, highlight indentation with at least that many spaces.
Otherwise, highlight neither.
@end defopt

@defopt magit-diff-hide-trailing-cr-characters

Whether to hide ^M characters at the end of a line in diffs.
@end defopt

@defopt magit-diff-highlight-hunk-region-functions

This option specifies the functions used to highlight the
hunk-internal region.

@code{magit-diff-highlight-hunk-region-dim-outside} overlays the outside of
the hunk internal selection with a face that causes the added and
removed lines to have the same background color as context lines.
This function should not be removed from the value of this option.

@code{magit-diff-highlight-hunk-region-using-overlays} and
@code{magit-diff-highlight-hunk-region-using-underline} emphasize the
region by placing delimiting horizonal lines before and after it.
Both of these functions have glitches which cannot be fixed due to
limitations of Emacs' display engine.  For more information see
@uref{https://github.com/magit/magit/issues/2758} ff.

Instead of, or in addition to, using delimiting horizontal lines,
to emphasize the boundaries, you may which to emphasize the text
itself, using @code{magit-diff-highlight-hunk-region-using-face}.

In terminal frames it's not possible to draw lines as the overlay
and underline variants normally do, so there they fall back to
calling the face function instead.
@end defopt

@defopt magit-diff-unmarked-lines-keep-foreground

This option controls whether added and removed lines outside the
hunk-internal region only lose their distinct background color or
also the foreground color.  Whether the outside of the region is
dimmed at all depends on @code{magit-diff-highlight-hunk-region-functions}.
@end defopt

@node Revision Buffer
@subsection Revision Buffer

@defopt magit-revision-insert-related-refs

Whether to show related refs in revision buffers.
@end defopt

@defopt magit-revision-show-gravatar

Whether to show gravatar images in revision buffers.

If non-nil, then the value has to be a cons-cell which specifies
where the gravatar images for the author and/or the committer are
inserted inside the text that was previously inserted according
to @code{magit-revision-header-format}.

Both cells are regular expressions.  The car specifies where to
insert the author gravatar image.  The top half of the image is
inserted right after the matched text, the bottom half on the
next line at the same offset.  The cdr specifies where to insert
the committer image, accordingly.  Either the car or the cdr may
be nil.
@end defopt

The diffs shown in the revision buffer may be automatically restricted
to a subset of the changed files.  If the revision buffer is displayed
from a log buffer, the revision buffer will share the same file
restriction as that log buffer (also see the command
@code{magit-diff-toggle-file-filter}).  Note, however, that the log's file
restriction will be ignored when @code{magit-log-arguments} includes
@code{--follow}.  In this case, the @code{-u} argument of the log popup can be
used to show the file-restricted diffs inline.

If the revision buffer is not displayed from a log buffer, the file
restriction is determined by the file restriction in the repository's
diff buffer, if it exists, and the value of the option
@code{magit-use-sticky-arguments}.

@node Ediffing
@section Ediffing

This section describes how to enter Ediff from Magit buffers.  For
information on how to use Ediff itself, see @ref{Top,,,ediff,}.

@table @asis
@kindex e
@cindex magit-ediff-dwim
@item @kbd{e} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-dwim})

Compare, stage, or resolve using Ediff.

This command tries to guess what file, and what commit or range the
user wants to compare, stage, or resolve using Ediff.  It might only
be able to guess either the file, or range/commit, in which case
the user is asked about the other.  It might not always guess right,
in which case the appropriate @code{magit-ediff-*} command has to be used
explicitly.  If it cannot read the user's mind at all, then it asks
the user for a command to run.

@kindex E
@cindex magit-ediff-popup
@item @kbd{E} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-popup})

This prefix command shows the following suffix commands in a popup
buffer.

@kindex E r
@cindex magit-ediff-compare
@item @kbd{E r} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-compare})

Compare two revisions of a file using Ediff.

If the region is active, use the revisions on the first and last
line of the region.  With a prefix argument, instead of diffing the
revisions, choose a revision to view changes along, starting at the
common ancestor of both revisions (i.e., use a "@dots{}"  range).

@kindex E m
@cindex magit-ediff-resolve
@item @kbd{E m} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-resolve})

Resolve outstanding conflicts in a file using Ediff, defaulting to
the file at point.

Provided that the value of @code{merge.conflictstyle} is @code{diff3}, you can
view the file's merge-base revision using @code{/} in the Ediff control
buffer.

In the rare event that you want to manually resolve all conflicts,
including those already resolved by Git, use
@code{ediff-merge-revisions-with-ancestor}.

@kindex E s
@cindex magit-ediff-stage
@item @kbd{E s} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-stage})

Stage and unstage changes to a file using Ediff, defaulting to the
file at point.

@kindex E u
@cindex magit-ediff-show-unstaged
@item @kbd{E u} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-show-unstaged})

Show unstaged changes to a file using Ediff.

@kindex E i
@cindex magit-ediff-show-staged
@item @kbd{E i} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-show-staged})

Show staged changes to a file using Ediff.

@kindex E w
@cindex magit-ediff-show-working-tree
@item @kbd{E w} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-show-working-tree})

Show changes in a file between @code{HEAD} and working tree using Ediff.

@kindex E c
@cindex magit-ediff-show-commit
@item @kbd{E c} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-show-commit})

Show changes to a file introduced by a commit using Ediff.

@kindex E z
@cindex magit-ediff-show-stash
@item @kbd{E z} @tie{}@tie{}@tie{}@tie{}(@code{magit-ediff-show-stash})

Show changes to a file introduced by a stash using Ediff.

@end table

@defopt magit-ediff-dwim-show-on-hunks

This option controls what command @code{magit-ediff-dwim} calls when
point is on uncommitted hunks.  When nil, always run
@code{magit-ediff-stage}.  Otherwise, use @code{magit-ediff-show-staged} and
@code{magit-ediff-show-unstaged} to show staged and unstaged changes,
respectively.
@end defopt

@defopt magit-ediff-show-stash-with-index

This option controls whether @code{magit-ediff-show-stash} includes a
buffer containing the file's state in the index at the time the
stash was created.  This makes it possible to tell which changes in
the stash were staged.
@end defopt

@defopt magit-ediff-quit-hook

This hook is run after quitting an Ediff session that was created
using a Magit command.  The hook functions are run inside the Ediff
control buffer, and should not change the current buffer.

This is similar to @code{ediff-quit-hook} but takes the needs of Magit into
account.  The regular @code{ediff-quit-hook} is ignored by Ediff sessions
that were created using a Magit command.
@end defopt

@node References Buffer
@section References Buffer

@table @asis
@kindex y
@cindex magit-show-refs-popup
@item @kbd{y} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-refs-popup})

List and compare references in a dedicated buffer.  By default all
refs are compared with @code{HEAD}, but with a prefix argument this command
instead acts as a prefix command and shows the following suffix
commands along with the appropriate infix arguments in a popup
buffer.

@kindex y y
@cindex magit-show-refs-head
@item @kbd{y y} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-refs-head})

List and compare references in a dedicated buffer.  Refs are
compared with @code{HEAD}.

@kindex y c
@cindex magit-show-refs-current
@item @kbd{y c} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-refs-current})

List and compare references in a dedicated buffer.  Refs are
compared with the current branch or @code{HEAD} if it is detached.

@kindex y o
@cindex magit-show-refs
@item @kbd{y o} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-refs})

List and compare references in a dedicated buffer.  Refs are
compared with a branch read from the user.

@end table

@defopt magit-refs-show-commit-count

Whether to show commit counts in Magit-Refs mode buffers.

@itemize
@item
@code{all} Show counts for branches and tags.

@item
@code{branch} Show counts for branches only.

@item
@code{nil} Never show counts.
@end itemize
The default is @code{nil} because anything else can be very expensive.
@end defopt

@defopt magit-refs-margin

This option specifies whether the margin is initially shown in
Magit-Refs mode buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@defopt magit-refs-margin-for-tags

This option specifies whether to show information about tags in the
margin.  This is disabled by default because it is slow if there are
many tags.
@end defopt

The following variables control how individual refs are displayed.  If
you change one of these variables (especially the "%c" part), then you
should also change the others to keep things aligned.  The following
%-sequences are supported:

@itemize
@item
@code{%a} Number of commits this ref has over the one we compare to.

@item
@code{%b} Number of commits the ref we compare to has over this one.

@item
@code{%c} Number of commits this ref has over the one we compare to.  For
the ref which all other refs are compared this is instead "@@", if
it is the current branch, or "#" otherwise.

@item
@code{%C} For the ref which all other refs are compared this is "@@", if it
is the current branch, or "#" otherwise.  For all other refs " ".

@item
@code{%h} Hash of this ref's tip.

@item
@code{%m} Commit summary of the tip of this ref.

@item
@code{%n} Name of this ref.

@item
@code{%u} Upstream of this local branch.

@item
@code{%U} Upstream of this local branch and additional local vs. upstream
information.

@end itemize

@defvar magit-refs-local-branch-format

Format used for local branches in refs buffers.
@end defvar

@defvar magit-refs-remote-branch-format

Format used for remote branches in refs buffers.
@end defvar

@defvar magit-refs-tags-format

Format used for tags in refs buffers.
@end defvar

@defvar magit-refs-indent-cherry-lines

Indentation of cherries in refs buffers.  This should be N-1 where N
is taken from "%Nc" in the above format strings.
@end defvar

@table @asis
@kindex RET
@cindex magit-visit-ref
@item @kbd{RET} @tie{}@tie{}@tie{}@tie{}(@code{magit-visit-ref})

This command visits the reference or revision at point in another
buffer.  If there is no revision at point or with a prefix argument
then it prompts for a revision.

This command behaves just like @code{magit-show-commit} as described above,
except if point is on a reference in a @code{magit-refs-mode} buffer, in
which case the behavior may be different, but only if you have
customized the option @code{magit-visit-ref-behavior}.

@end table

@defopt magit-visit-ref-behavior

This option controls how @code{magit-visit-ref} behaves in @code{magit-refs-mode}
buffers.

By default @code{magit-visit-ref} behaves like @code{magit-show-commit}, in all
buffers, including @code{magit-refs-mode} buffers.  When the type of the
section at point is @code{commit} then "RET" is bound to @code{magit-show-commit},
and when the type is either @code{branch} or @code{tag} then it is bound to
@code{magit-visit-ref}.

"RET" is one of Magit's most essential keys and at least by default
it should behave consistently across all of Magit, especially
because users quickly learn that it does something very harmless; it
shows more information about the thing at point in another buffer.

However "RET" used to behave differently in @code{magit-refs-mode} buffers,
doing surprising things, some of which cannot really be described as
"visit this thing".  If you've grown accustomed this behavior, you
can restore it by adding one or more of the below symbols to the
value of this option.  But keep in mind that by doing so you don't
only introduce inconsistencies, you also lose some functionality and
might have to resort to @code{M-x magit-show-commit} to get it back.

@code{magit-visit-ref} looks for these symbols in the order in which they
are described here.  If the presence of a symbol applies to the
current situation, then the symbols that follow do not affect the
outcome.

@itemize
@item
@code{focus-on-ref}

With a prefix argument update the buffer to show commit counts
and lists of cherry commits relative to the reference at point
instead of relative to the current buffer or @code{HEAD}.

Instead of adding this symbol, consider pressing "C-u y o RET".


@item
@code{create-branch}

If point is on a remote branch, then create a new local branch
with the same name, use the remote branch as its upstream, and
then check out the local branch.

Instead of adding this symbol, consider pressing "b c RET RET",
like you would do in other buffers.


@item
@code{checkout-any}

Check out the reference at point.  If that reference is a tag
or a remote branch, then this results in a detached @code{HEAD}.

Instead of adding this symbol, consider pressing "b b RET",
like you would do in other buffers.


@item
@code{checkout-branch}

Check out the local branch at point.

Instead of adding this symbol, consider pressing "b b RET",
like you would do in other buffers.
@end itemize
@end defopt

@menu
* References Sections::
@end menu

@node References Sections
@subsection References Sections

The contents of references buffers is controlled using the hook
@code{magit-refs-sections-hook}.  See @ref{Section Hooks} to learn about such hooks
and how to customize them.  All of the below functions are members of
the default value.  Note that it makes much less sense to customize
this hook than it does for the respective hook used for the status
buffer.

@defopt magit-refs-sections-hook

Hook run to insert sections into a references buffer.
@end defopt

@defun magit-insert-local-branches

Insert sections showing all local branches.
@end defun

@defun magit-insert-remote-branches

Insert sections showing all remote-tracking branches.
@end defun

@defun magit-insert-tags

Insert sections showing all tags.
@end defun

@node Bisecting
@section Bisecting

Also see 
@ifinfo
@ref{git-bisect,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-bisect">git-bisect(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-bisect(1) manpage.
@end iftex

@table @asis
@kindex B
@cindex magit-bisect-popup
@item @kbd{B} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-popup})

This prefix command shows the following suffix commands in a
popup buffer.
@end table

When bisecting is not in progress, then the popup buffer features the
following commands.

@table @asis
@kindex B B
@cindex magit-bisect-start
@item @kbd{B B} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-start})

Start a bisect session.

Bisecting a bug means to find the commit that introduced it.
This command starts such a bisect session by asking for a known
good and a bad commit.

@kindex B s
@cindex magit-bisect-run
@item @kbd{B s} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-run})

Bisect automatically by running commands after each step.
@end table

When bisecting is in progress, then the popup buffer features these
commands instead.

@table @asis
@kindex B b
@cindex magit-bisect-bad
@item @kbd{B b} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-bad})

Mark the current commit as bad.  Use this after you have asserted
that the commit does contain the bug in question.

@kindex B g
@cindex magit-bisect-good
@item @kbd{B g} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-good})

Mark the current commit as good.  Use this after you have asserted
that the commit does not contain the bug in question.

@kindex B k
@cindex magit-bisect-skip
@item @kbd{B k} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-skip})

Skip the current commit.  Use this if for some reason the current
commit is not a good one to test.  This command lets Git choose a
different one.

@kindex B r
@cindex magit-bisect-reset
@item @kbd{B r} @tie{}@tie{}@tie{}@tie{}(@code{magit-bisect-reset})

After bisecting, cleanup bisection state and return to original
@code{HEAD}.
@end table

By default the status buffer shows information about the ongoing
bisect session.

@defopt magit-bisect-show-graph

This option controls whether a graph is displayed for the log of
commits that still have to be bisected.
@end defopt

@node Visiting Blobs
@section Visiting Blobs

@table @asis
@kindex M-x magit-find-file
@cindex magit-find-file
@item @kbd{M-x magit-find-file} @tie{}@tie{}@tie{}@tie{}(@code{magit-find-file})

View FILE from REV.  Switch to a buffer visiting blob REV:FILE,
creating one if none already exists.

@kindex M-x magit-find-file-other-window
@cindex magit-find-file-other-window
@item @kbd{M-x magit-find-file-other-window} @tie{}@tie{}@tie{}@tie{}(@code{magit-find-file-other-window})

View FILE from REV, in another window.  Like @code{magit-find-file}, but
create a new window or reuse an existing one.
@end table

@node Blaming
@section Blaming

Also see 
@ifinfo
@ref{git-blame,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-blame">git-blame(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-blame(1) manpage.
@end iftex

@table @asis
@kindex M-x magit-blame
@cindex magit-blame
@item @kbd{M-x magit-blame} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame})

Display edit history of FILE up to REVISION.

Interactively blame the file being visited in the current buffer.
If the buffer visits a revision of that file, then blame up to that
revision.  Otherwise, blame the file's full history, including
uncommitted changes.

If Magit-Blame mode is already turned on then blame recursively, by
visiting REVISION:FILE (using @code{magit-find-file}), where revision is
the revision before the revision that added the lines at point.

ARGS is a list of additional arguments to pass to @code{git blame}; only
arguments available from @code{magit-blame-popup} should be used.

@kindex M-x magit-blame-popup
@cindex magit-blame-popup
@item @kbd{M-x magit-blame-popup} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-popup})

This prefix command shows the above suffix command along with the
appropriate infix arguments in a popup buffer.

@kindex RET
@cindex magit-show-commit
@item @kbd{RET} @tie{}@tie{}@tie{}@tie{}(@code{magit-show-commit})

Show the commit at point.  If there is no commit at point or with a
prefix argument, prompt for a commit.

@kindex SPC
@cindex magit-diff-show-or-scroll-up
@item @kbd{SPC} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-show-or-scroll-up})

Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer,
or if that buffer is already being displayed in the current frame
and contains information about that commit or stash, then instead
scroll the buffer up.  If there is no commit or stash at point, then
prompt for a commit.

@kindex DEL
@cindex magit-diff-show-or-scroll-down
@item @kbd{DEL} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-show-or-scroll-down})

Update the commit or diff buffer for the thing at point.

Either show the commit or stash at point in the appropriate buffer,
or if that buffer is already being displayed in the current frame
and contains information about that commit or stash, then instead
scroll the buffer down.  If there is no commit or stash at point,
then prompt for a commit.

@kindex n
@cindex magit-blame-next-chunk
@item @kbd{n} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-next-chunk})

Move to the next chunk.

@kindex N
@cindex magit-blame-next-chunk-same-commit
@item @kbd{N} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-next-chunk-same-commit})

Move to the next chunk from the same commit.

@kindex p
@cindex magit-blame-previous-chunk
@item @kbd{p} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-previous-chunk})

Move to the previous chunk.

@kindex P
@cindex magit-blame-previous-chunk-same-commit
@item @kbd{P} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-previous-chunk-same-commit})

Move to the previous chunk from the same commit.

@kindex q
@cindex magit-blame-quit
@item @kbd{q} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-quit})

Turn off Magit-Blame mode.  If the buffer was created during a
recursive blame, then also kill the buffer.

@kindex M-w
@cindex magit-blame-copy-hash
@item @kbd{M-w} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-copy-hash})

Save the hash of the current chunk's commit to the kill ring.

When the region is active, then save that to the @code{kill-ring},
like @code{kill-ring-save} would.

@kindex t
@cindex magit-blame-toggle-headings
@item @kbd{t} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-toggle-headings})

Show or hide blame chunk headings.

@end table

@defopt magit-blame-heading-format

Format string used for blame headings.
@end defopt

@defopt magit-blame-time-format

Format string used for time strings in blame headings.
@end defopt

@defopt magit-blame-show-headings

Whether to initially show blame block headings.  The headings can
also be toggled locally using command @code{magit-blame-toggle-headings}.
@end defopt

@defopt magit-blame-goto-chunk-hook

Hook run by @code{magit-blame-next-chunk} and @code{magit-blame-previous-chunk}.
@end defopt

@node Manipulating
@chapter Manipulating

@menu
* Repository Setup::
* Staging and Unstaging::
* Applying::
* Committing::
* Branching::
* Merging::
* Resolving Conflicts::
* Rebasing::
* Cherry Picking::
* Resetting::
* Stashing::
@end menu

@node Repository Setup
@section Repository Setup

@table @asis
@kindex M-x magit-init
@cindex magit-init
@item @kbd{M-x magit-init} @tie{}@tie{}@tie{}@tie{}(@code{magit-init})

This command initializes a repository and then shows the status
buffer for the new repository.

If the directory is below an existing repository, then the user has
to confirm that a new one should be created inside.  If the
directory is the root of the existing repository, then the user has
to confirm that it should be reinitialized.

@kindex M-x magit-clone
@cindex magit-clone
@item @kbd{M-x magit-clone} @tie{}@tie{}@tie{}@tie{}(@code{magit-clone})

This command clones a repository and then shows the status buffer
for the new repository.

The user is queried for a remote url and a local directory.

@end table

@defopt magit-clone-set-remote.pushDefault

Whether to set the value of @code{remote.pushDefault} after cloning.

If @code{t}, then set without asking.  If @code{nil}, then don't set.  If @code{ask},
then ask the user every time she clones a repository.
@end defopt

@node Staging and Unstaging
@section Staging and Unstaging

Like Git, Magit can of course stage and unstage complete files.
Unlike Git, it also allows users to gracefully un-/stage
individual hunks and even just part of a hunk.  To stage individual
hunks and parts of hunks using Git directly, one has to use the very
modal and rather clumsy interface of a @code{git add --interactive} session.

With Magit, on the other hand, one can un-/stage individual hunks by
just moving point into the respective section inside a diff displayed
in the status buffer or a separate diff buffer and typing @code{s} or @code{u}.  To
operate on just parts of a hunk, mark the changes that should be
un-/staged using the region and then press the same key that would be
used to un-/stage.  To stage multiple files or hunks at once use a
region that starts inside the heading of such a section and ends
inside the heading of a sibling section of the same type.

Besides staging and unstaging, Magit also provides several other
"apply variants" that can also operate on a file, multiple files at
once, a hunk, multiple hunks at once, and on parts of a hunk.  These
apply variants are described in the next section.

You can also use Ediff to stage and unstage.  See @ref{Ediffing}.

@table @asis
@kindex s
@cindex magit-stage
@item @kbd{s} @tie{}@tie{}@tie{}@tie{}(@code{magit-stage})

Add the change at point to the staging area.

With a prefix argument and an untracked file (or files) at point,
stage the file but not its content.  This makes it possible to stage
only a subset of the new file's changes.

@kindex S
@cindex magit-stage-modified
@item @kbd{S} @tie{}@tie{}@tie{}@tie{}(@code{magit-stage-modified})

Stage all changes to files modified in the worktree.  Stage all new
content of tracked files and remove tracked files that no longer
exist in the working tree from the index also.  With a prefix
argument also stage previously untracked (but not ignored) files.

@kindex u
@cindex magit-unstage
@item @kbd{u} @tie{}@tie{}@tie{}@tie{}(@code{magit-unstage})

Remove the change at point from the staging area.

Only staged changes can be unstaged.  But by default this command
performs an action that is somewhat similar to unstaging, when it is
called on a committed change: it reverses the change in the index
but not in the working tree.

@kindex U
@cindex magit-unstage-all
@item @kbd{U} @tie{}@tie{}@tie{}@tie{}(@code{magit-unstage-all})

Remove all changes from the staging area.

@end table

@defopt magit-unstage-committed

This option controls whether @code{magit-unstage} "unstages" committed
changes by reversing them in the index but not the working tree.
The alternative is to raise an error.
@end defopt

@table @asis
@kindex M-x magit-reverse-in-index
@cindex magit-reverse-in-index
@item @kbd{M-x magit-reverse-in-index} @tie{}@tie{}@tie{}@tie{}(@code{magit-reverse-in-index})

This command reverses the committed change at point in the index but
not the working tree.  By default no key is bound directly to this
command, but it is indirectly called when @code{u} (@code{magit-unstage}) is
pressed on a committed change.

This allows extracting a change from @code{HEAD}, while leaving it in the
working tree, so that it can later be committed using a separate
commit.  A typical workflow would be:

@itemize
@item
Optionally make sure that there are no uncommitted changes.

@item
Visit the @code{HEAD} commit and navigate to the change that should
not have been included in that commit.

@item
Type @code{u} (@code{magit-unstage}) to reverse it in the index.
This assumes that @code{magit-unstage-committed-changes} is non-nil.

@item
Type @code{c e} to extend @code{HEAD} with the staged changes,
including those that were already staged before.

@item
Optionally stage the remaining changes using @code{s} or @code{S} and then
type @code{c c} to create a new commit.
@end itemize

@kindex M-x magit-reset-index
@cindex magit-reset-index
@item @kbd{M-x magit-reset-index} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset-index})

Reset the index to some commit.  The commit is read from the user
and defaults to the commit at point.  If there is no commit at
point, then it defaults to @code{HEAD}.
@end table

@menu
* Staging from File-Visiting Buffers::
@end menu

@node Staging from File-Visiting Buffers
@subsection Staging from File-Visiting Buffers

Fine-grained un-/staging has to be done from the status or a diff
buffer, but it's also possible to un-/stage all changes made to the
file visited in the current buffer right from inside that buffer.

@table @asis
@kindex M-x magit-stage-file
@cindex magit-stage-file
@item @kbd{M-x magit-stage-file} @tie{}@tie{}@tie{}@tie{}(@code{magit-stage-file})

When invoked inside a file-visiting buffer, then stage all changes
to that file.  In a Magit buffer, stage the file at point if any.
Otherwise prompt for a file to be staged.  With a prefix argument
always prompt the user for a file, even in a file-visiting buffer or
when there is a file section at point.

@kindex M-x magit-unstage-file
@cindex magit-unstage-file
@item @kbd{M-x magit-unstage-file} @tie{}@tie{}@tie{}@tie{}(@code{magit-unstage-file})

When invoked inside a file-visiting buffer, then unstage all changes
to that file.  In a Magit buffer, unstage the file at point if any.
Otherwise prompt for a file to be unstaged.  With a prefix argument
always prompt the user for a file, even in a file-visiting buffer or
when there is a file section at point.
@end table

@node Applying
@section Applying

Magit provides several "apply variants": stage, unstage, discard,
reverse, and "regular apply".  At least when operating on a hunk they
are all implemented using @code{git apply}, which is why they are called
"apply variants".

@itemize
@item
Stage.  Apply a change from the working tree to the index.  The change
also remains in the working tree.


@item
Unstage.  Remove a change from the index.  The change remains in the
working tree.


@item
Discard.  On a staged change, remove it from the working tree and the
index.  On an unstaged change, remove it from the working tree only.


@item
Reverse.  Reverse a change in the working tree.  Both committed and
staged changes can be reversed.  Unstaged changes cannot be
reversed.  Discard them instead.


@item
Apply.  Apply a change to the working tree.  Both committed and staged
changes can be applied.  Unstaged changes cannot be applied - as
they already have been applied.
@end itemize

The previous section described the staging and unstaging commands.
What follows are the commands which implement the remaining apply
variants.

@table @asis
@kindex a
@cindex magit-apply
@item @kbd{a} @tie{}@tie{}@tie{}@tie{}(@code{magit-apply})

Apply the change at point to the working tree.

With a prefix argument fallback to a 3-way merge.  Doing so causes
the change to be applied to the index as well.

@kindex k
@cindex magit-discard
@item @kbd{k} @tie{}@tie{}@tie{}@tie{}(@code{magit-discard})

Remove the change at point from the working tree.

@kindex v
@cindex magit-reverse
@item @kbd{v} @tie{}@tie{}@tie{}@tie{}(@code{magit-reverse})

Reverse the change at point in the working tree.

With a prefix argument fallback to a 3-way merge.  Doing so causes
the change to be applied to the index as well.
@end table

With a prefix argument all apply variants attempt a 3-way merge when
appropriate (i.e. when @code{git apply} is used internally).

@node Committing
@section Committing

When the user initiates a commit, Magit calls @code{git commit} without any
arguments, so Git has to get it from the user.  It creates the file
@code{.git/COMMIT_EDITMSG} and then opens that file in an editor.  Magit
arranges for that editor to be the Emacsclient.  Once the user
finishes the editing session, the Emacsclient exits and Git creates the
commit using the file's content as message.

@menu
* Initiating a Commit::
* Editing Commit Messages::
@end menu

@node Initiating a Commit
@subsection Initiating a Commit

Also see 
@ifinfo
@ref{git-commit,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-commit">git-commit(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-commit(1) manpage.
@end iftex

@table @asis
@kindex c
@cindex magit-commit-popup
@item @kbd{c} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex c c
@cindex magit-commit
@item @kbd{c c} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit})

Create a new commit on @code{HEAD}.  With a prefix argument amend to the
commit at @code{HEAD} instead.

@kindex c a
@cindex magit-commit-amend
@item @kbd{c a} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-amend})

Amend the last commit.

@kindex c e
@cindex magit-commit-extend
@item @kbd{c e} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-extend})

Amend the last commit, without editing the message.  With a prefix
argument keep the committer date, otherwise change it.  The option
@code{magit-commit-extend-override-date} can be used to inverse the meaning
of the prefix argument.

Non-interactively respect the optional OVERRIDE-DATE argument and
ignore the option.

@kindex c w
@cindex magit-commit-reword
@item @kbd{c w} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-reword})

Reword the last commit, ignoring staged changes.  With a prefix
argument keep the committer date, otherwise change it.  The option
@code{magit-commit-reword-override-date} can be used to inverse the meaning
of the prefix argument.

Non-interactively respect the optional OVERRIDE-DATE argument and
ignore the option.

@kindex c f
@cindex magit-commit-fixup
@item @kbd{c f} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-fixup})

Create a fixup commit.

With a prefix argument the target commit has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option @code{magit-commit-squash-confirm}.

@kindex c F
@cindex magit-commit-instant-fixup
@item @kbd{c F} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-instant-fixup})

Create a fixup commit and instantly rebase.

@kindex c s
@cindex magit-commit-squash
@item @kbd{c s} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-squash})

Create a squash commit, without editing the squash message.

With a prefix argument the target commit has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option @code{magit-commit-squash-confirm}.

@kindex c S
@cindex magit-commit-instant-squash
@item @kbd{c S} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-instant-squash})

Create a squash commit and instantly rebase.

@kindex c A
@cindex magit-commit-augment
@item @kbd{c A} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-augment})

Create a squash commit, editing the squash message.

With a prefix argument the target commit has to be confirmed.
Otherwise the commit at point may be used without confirmation
depending on the value of option @code{magit-commit-squash-confirm}.

@end table

@defopt magit-commit-ask-to-stage

Whether to ask to stage everything when committing and nothing is
staged.
@end defopt

@defopt magit-commit-extend-override-date

Whether using @code{magit-commit-extend} changes the committer date.
@end defopt

@defopt magit-commit-reword-override-date

Whether using @code{magit-commit-reword} changes the committer date.
@end defopt

@defopt magit-commit-squash-confirm

Whether the commit targeted by squash and fixup has to be confirmed.
When non-nil then the commit at point (if any) is used as default
choice.  Otherwise it has to be confirmed.  This option only affects
@code{magit-commit-squash} and @code{magit-commit-fixup}.  The "instant" variants
always require confirmation because making an error while using
those is harder to recover from.
@end defopt

@node Editing Commit Messages
@subsection Editing Commit Messages

After initiating a commit as described in the previous section, two new
buffers appear.  One shows the changes that are about to committed,
while the other is used to write the message.  All regular editing
commands are available in the commit message buffer.  This section
only describes the additional commands.

Commit messages are edited in an edit session - in the background Git
is waiting for the editor, in our case the Emacsclient, to save the
commit message in a file (in most cases @code{.git/COMMIT_EDITMSG}) and then
return.  If the Emacsclient returns with a non-zero exit status then
Git does not create the commit.  So the most important commands are
those for finishing and aborting the commit.

@table @asis
@kindex C-c C-c
@cindex with-editor-finish
@item @kbd{C-c C-c} @tie{}@tie{}@tie{}@tie{}(@code{with-editor-finish})

Finish the current editing session by returning with exit code 0.
Git then creates the commit using the message it finds in the file.

@kindex C-c C-k
@cindex with-editor-cancel
@item @kbd{C-c C-k} @tie{}@tie{}@tie{}@tie{}(@code{with-editor-cancel})

Cancel the current editing session by returning with exit code 1.
Git then cancels the commit, but leaves the file untouched.
@end table

In addition to being used by Git, these messages may also be stored in
a ring that persists until Emacs is closed.  By default the message is
stored at the beginning and the end of an edit session (regardless of
whether the session is finished successfully or was canceled).  It is
sometimes useful to bring back messages from that ring.

@table @asis
@kindex C-c M-s
@cindex git-commit-save-message
@item @kbd{C-c M-s} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-save-message})

Save the current buffer content to the commit message ring.

@kindex M-p
@cindex git-commit-prev-message
@item @kbd{M-p} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-prev-message})

Cycle backward through the commit message ring, after saving the
current message to the ring.  With a numeric prefix ARG, go back
ARG comments.

@kindex M-n
@cindex git-commit-next-message
@item @kbd{M-n} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-next-message})

Cycle forward through the commit message ring, after saving the
current message to the ring.  With a numeric prefix ARG, go back
ARG comments.
@end table

By default the diff for the changes that are about to be committed are
automatically shown when invoking the commit.  When amending to an
existing commit it may be useful to show either the changes that are
about to be added to that commit or to show those changes together
with those that are already committed.

@table @asis
@kindex C-c C-d
@cindex magit-diff-while-committing
@item @kbd{C-c C-d} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-while-committing})

While committing, show the changes that are about to be committed.
While amending, invoking the command again toggles between showing
just the new changes or all the changes that will be committed.

@kindex C-c C-w
@cindex magit-pop-revision-stack
@item @kbd{C-c C-w} @tie{}@tie{}@tie{}@tie{}(@code{magit-pop-revision-stack})

This command inserts a representation of a revision into the current
buffer.  It can be used inside buffers used to write commit messages
but also in other buffers such as buffers used to edit emails or
ChangeLog files.

By default this command pops the revision which was last added to
the @code{magit-revision-stack} and inserts it into the current buffer
according to @code{magit-pop-revision-stack-format}.  Revisions can be put
on the stack using @code{magit-copy-section-value} and
@code{magit-copy-buffer-revision}.

If the stack is empty or with a prefix argument it instead reads a
revision in the minibuffer.  By using the minibuffer history this
allows selecting an item which was popped earlier or to insert an
arbitrary reference or revision without first pushing it onto the
stack.

When reading the revision from the minibuffer, then it might not
be possible to guess the correct repository.  When this command
is called inside a repository (e.g. while composing a commit
message), then that repository is used.  Otherwise (e.g. while
composing an email) then the repository recorded for the top
element of the stack is used (even though we insert another
revision).  If not called inside a repository and with an empty
stack, or with two prefix arguments, then read the repository in
the minibuffer too.

@end table

@defopt magit-pop-revision-stack-format

This option controls how the command @code{magit-pop-revision-stack}
inserts a revision into the current buffer.

The entries on the stack have the format @code{(HASH TOPLEVEL)} and this
option has the format @code{(POINT-FORMAT EOB-FORMAT INDEX-REGEXP)}, all
of which may be nil or a string (though either one of EOB-FORMAT
or POINT-FORMAT should be a string, and if INDEX-REGEXP is
non-nil, then the two formats should be too).

First INDEX-REGEXP is used to find the previously inserted entry,
by searching backward from point.  The first submatch must match
the index number.  That number is incremented by one, and becomes
the index number of the entry to be inserted.  If you don't want
to number the inserted revisions, then use nil for INDEX-REGEXP.

If INDEX-REGEXP is non-nil then both POINT-FORMAT and EOB-FORMAT
should contain \"%N\", which is replaced with the number that was
determined in the previous step.

Both formats, if non-nil and after removing %N, are then expanded
using `git show --format=FORMAT @dots{}' inside TOPLEVEL.

The expansion of POINT-FORMAT is inserted at point, and the
expansion of EOB-FORMAT is inserted at the end of the buffer (if the
buffer ends with a comment, then it is inserted right before that).
@end defopt

Some projects use pseudo headers in commit messages.  Magit colorizes
such headers and provides some commands to insert such headers.

@defopt git-commit-known-pseudo-headers

A list of Git pseudo headers to be highlighted.
@end defopt

@table @asis
@kindex C-c C-a
@cindex git-commit-ack
@item @kbd{C-c C-a} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-ack})

Insert a header acknowledging that you have looked at the commit.

@kindex C-c C-r
@cindex git-commit-review
@item @kbd{C-c C-r} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-review})

Insert a header acknowledging that you have reviewed the commit.

@kindex C-c C-s
@cindex git-commit-signoff
@item @kbd{C-c C-s} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-signoff})

Insert a header to sign off the commit.

@kindex C-c C-t
@cindex git-commit-test
@item @kbd{C-c C-t} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-test})

Insert a header acknowledging that you have tested the commit.

@kindex C-c C-o
@cindex git-commit-cc
@item @kbd{C-c C-o} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-cc})

Insert a header mentioning someone who might be interested.

@kindex C-c C-p
@cindex git-commit-reported
@item @kbd{C-c C-p} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-reported})

Insert a header mentioning the person who reported the issue being
fixed by the commit.

@kindex C-c C-i
@cindex git-commit-suggested
@item @kbd{C-c C-i} @tie{}@tie{}@tie{}@tie{}(@code{git-commit-suggested})

Insert a header mentioning the person who suggested the change.
@end table

@code{git-commit-mode} is a minor mode that is only used to establish
the above key bindings.  This allows using an arbitrary major mode
when editing the commit message.  It's even possible to use a
different major mode in different repositories, which is useful when
different projects impose different commit message conventions.

@defopt git-commit-major-mode

The value of this option is the major mode used to edit Git commit
messages.
@end defopt

Because @code{git-commit-mode} is a minor mode, we don't use its mode hook
to setup the buffer, except for the key bindings.  All other setup
happens in the function @code{git-commit-setup}, which among other things runs
the hook @code{git-commit-setup-hook}.  The following functions are suitable
for that hook.

@defopt git-commit-setup-hook

Hook run at the end of @code{git-commit-setup}.
@end defopt

@defun magit-revert-buffers &optional force

Revert unmodified file-visiting buffers of the current repository.

If either @code{magit-revert-buffers} is non-nil and @code{inhibit-magit-revert}
is nil, or if optional FORCE is non-nil, then revert all unmodified
buffers that visit files being tracked in the current repository.
@end defun

@defun git-commit-save-message

Save the current buffer content to the commit message ring.
@end defun

@defun git-commit-setup-changelog-support

After this function is called, ChangeLog entries are treated as
paragraphs.
@end defun

@defun git-commit-turn-on-auto-fill

Turn on @code{auto-fill-mode} and set @code{fill-column} to the value of
@code{git-commit-fill-column}.
@end defun

@defun git-commit-turn-on-flyspell

Turn on Flyspell mode.  Also prevent comments from being checked and
finally check current non-comment text.
@end defun

@defun git-commit-propertize-diff

Propertize the diff shown inside the commit message buffer.  Git
inserts such diffs into the commit message template when the
@code{--verbose} argument is used.  Magit's commit popup by default does
not offer that argument because the diff that is shown in a separate
buffer is more useful.  But some users disagree, which is why this
function exists.
@end defun

@defun with-editor-usage-message

Show usage information in the echo area.
@end defun

Magit also helps with writing @strong{good} commit messages by complaining when
certain rules are violated.

@defopt git-commit-summary-max-length

The intended maximal length of the summary line of commit messages.
Characters beyond this column are colorized to indicate that this
preference has been violated.
@end defopt

@defopt git-commit-fill-column

Column beyond which automatic line-wrapping should happen in commit
message buffers.
@end defopt

@defopt git-commit-finish-query-functions

List of functions called to query before performing commit.

The commit message buffer is current while the functions are called.
If any of them returns nil, then the commit is not performed and the
buffer is not killed.  The user should then fix the issue and try
again.

The functions are called with one argument.  If it is non-nil then
that indicates that the user used a prefix argument to force
finishing the session despite issues.  Functions should usually
honor this wish and return non-nil.
@end defopt

@defun git-commit-check-style-conventions

Check for violations of certain basic style conventions.  For each
violation ask the user if she wants to proceed anyway.  This makes
sure the summary line isn't too long and that the second line is
empty.
@end defun

To show no diff while committing remove @code{magit-commit-diff} from
@code{server-switch-hook}.

@node Branching
@section Branching

@menu
* The Two Remotes::
* The Branch Popup::
* The Branch Config Popup::
@end menu

@node The Two Remotes
@subsection The Two Remotes

The upstream branch of some local branch is the branch into which the
commits on that local branch should eventually be merged, usually
something like @code{origin/master}.  For the @code{master} branch itself the
upstream branch and the branch it is being pushed to, are usually the
same remote branch.  But for a feature branch the upstream branch and
the branch it is being pushed to should differ.

The commits on feature branches too should @emph{eventually} end up in a
remote branch such as @code{origin/master} or @code{origin/maint}.  Such a branch
should therefore be used as the upstream.  But feature branches
shouldn't be pushed directly to such branches.  Instead a feature
branch @code{my-feature} is usually pushed to @code{my-fork/my-feature} or if you
are a contributor @code{origin/my-feature}.  After the new feature has been
reviewed, the maintainer merges the feature into @code{master}.  And finally
@code{master} (not @code{my-feature} itself) is pushed to @code{origin/master}.

But new features seldom are perfect on the first try, and so feature
branches usually have to be reviewed, improved, and re-pushed several
times.  Pushing should therefore be easy to do, and for that reason
many Git users have concluded that it is best to use the remote branch
to which the local feature branch is being pushed as its upstream.

But luckily Git has long ago gained support for a push-remote which
can be configured separately from the upstream branch, using the
variables @code{branch.<name>.pushRemote} and @code{remote.pushDefault}.  So we no
longer have to choose which of the two remotes should be used as "the
remote".

Each of the fetching, pulling, and pushing popups features three
commands that act on the current branch and some other branch.  Of
these, @code{p} is bound to a command which acts on the push-remote, @code{u} is
bound to a command which acts on the upstream, and @code{e} is bound to a
command which acts on any other branch.  The status buffer shows
unpushed and unpulled commits for both the push-remote and the
upstream.

It's fairly simple to configure these two remotes.  The values of all
the variables that are related to fetching, pulling, and pushing (as
well as some other branch-related variables) can be inspected and
changed using the popup @code{magit-branch-config-popup}, which is a
sub-popup of many popups that deal with branches.  It is also possible
to set the push-remote or upstream while pushing (see @ref{Pushing}).

@node The Branch Popup
@subsection The Branch Popup

The popup @code{magit-branch-popup} is used to create and checkout branches,
and to make changes to existing branches.  It is not used to fetch,
pull, merge, rebase, or push branches, i.e. this popup deals with
branches themselves, not with the commits reachable from them.  Those
features are available from separate popups.

@table @asis
@kindex b
@cindex magit-branch-popup
@item @kbd{b} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-popup})

This prefix command shows the following suffix commands in a popup
buffer.

By default it also displays the values of some branch-related Git
variables and allows changing their values, just like the
specialized @code{magit-branch-config-popup} does.

@end table

@defopt magit-branch-popup-show-variables

Whether the @code{magit-branch-popup} shows Git variables.  This defaults
to t to avoid changing key bindings.  When set to nil, no variables
are displayed directly in this popup, and the sub-popup
@code{magit-branch-config-popup} has to be used indead to view and change
branch related variables.
@end defopt

@table @asis
@kindex b b
@cindex magit-checkout
@item @kbd{b b} @tie{}@tie{}@tie{}@tie{}(@code{magit-checkout})

Checkout a revision read in the minibuffer and defaulting to the
branch or arbitrary revision at point.  If the revision is a local
branch then that becomes the current branch.  If it is something
else then @code{HEAD} becomes detached.  Checkout fails if the working tree
or the staging area contain changes.

@kindex b n
@cindex magit-branch
@item @kbd{b n} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch})

Create a new branch.  The user is asked for a branch or arbitrary
revision to use as the starting point of the new branch.  When a
branch name is provided, then that becomes the upstream branch of
the new branch.  The name of the new branch is also read in the
minibuffer.

Also see option @code{magit-branch-prefer-remote-upstream}.

@kindex b c
@cindex magit-branch-and-checkout
@item @kbd{b c} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-and-checkout})

This command creates a new branch like @code{magit-branch}, but then also
checks it out.

Also see option @code{magit-branch-prefer-remote-upstream}.

@kindex b s
@cindex magit-branch-spinoff
@item @kbd{b s} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-spinoff})

This command creates and checks out a new branch starting at and
tracking the current branch.  That branch in turn is reset to the
last commit it shares with its upstream.  If the current branch has
no upstream or no unpushed commits, then the new branch is created
anyway and the previously current branch is not touched.

This is useful to create a feature branch after work has already
began on the old branch (likely but not necessarily "master").

If the current branch is a member of the value of option
@code{magit-branch-prefer-remote-upstream} (which see), then the current
branch will be used as the starting point as usual, but the upstream
of the starting-point may be used as the upstream of the new branch,
instead of the starting-point itself.

If optional FROM is non-nil, then the source branch is reset
to @code{FROM~}, instead of to the last commit it shares with its
upstream.  Interactively, FROM is only ever non-nil, if the
region selects some commits, and among those commits, FROM is
the commit that is the fewest commits ahead of the source
branch.  (It not yet possible to spin off a single commit,
unless it is the only unpushed commit.  See #2920.)

The commit at the other end of the selection actually does not
matter, all commits between FROM and @code{HEAD} are moved to the new
branch.  If FROM is not reachable from @code{HEAD} or is reachable from the
source branch's upstream, then an error is raised.

@kindex b x
@cindex magit-branch-reset
@item @kbd{b x} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-reset})

This command resets a branch, defaulting to the branch at point, to
the tip of another branch or any other commit.

When the branch being reset is the current branch, then a hard reset
is performed.  If there are any uncommitted changes, then the user
has to confirm the reset because those changes would be lost.

This is useful when you have started work on a feature branch but
realize it's all crap and want to start over.

When resetting to another branch and a prefix argument is used, then
the target branch is set as the upstream of the branch that is being
reset.

@kindex b k
@cindex magit-branch-delete
@item @kbd{b k} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-delete})

Delete one or multiple branches.  If the region marks multiple
branches, then offer to delete those.  Otherwise, prompt for a single
branch to be deleted, defaulting to the branch at point.

@kindex b r
@cindex magit-branch-rename
@item @kbd{b r} @tie{}@tie{}@tie{}@tie{}(@code{magit-branch-rename})

Rename a branch.  The branch and the new name are read in the
minibuffer.  With prefix argument the branch is renamed even if that
name conflicts with an existing branch.

@end table

@defopt magit-branch-read-upstream-first

When creating a branch, whether to read the upstream branch before
the name of the branch that is to be created.  The default is @code{nil},
and I recommend you leave it at that.
@end defopt

@defopt magit-branch-prefer-remote-upstream

This option specifies whether remote upstreams are favored over
local upstreams when creating new branches.

When a new branch is created, then the branch, commit, or stash at
point is suggested as the starting point of the new branch, or if
there is no such revision at point the current branch.  In either
case the user may choose another starting point.

If the chosen starting point is a branch, then it may also be set
as the upstream of the new branch, depending on the value of the
Git variable `branch.autoSetupMerge'.  By default this is done
for remote branches, but not for local branches.

You might prefer to always use some remote branch as upstream.
If the chosen starting point is (1) a local branch, (2) whose
name matches a member of the value of this option, (3) the
upstream of that local branch is a remote branch with the same
name, and (4) that remote branch can be fast-forwarded to the
local branch, then the chosen branch is used as starting point,
but its own upstream is used as the upstream of the new branch.

Members of this option's value are treated as branch names that
have to match exactly unless they contain a character that makes
them invalid as a branch name.  Recommended characters to use
to trigger interpretation as a regexp are "*" and "^".  Some
other characters which you might expect to be invalid, actually
are not, e.g. ".+$" are all perfectly valid.  More precisely,
if `git check-ref-format --branch STRING' exits with a non-zero
status, then treat STRING as a regexp.

Assuming the chosen branch matches these conditions you would end
up with with e.g.:

@example
feature --upstream--> origin/master
@end example

instead of

@example
feature --upstream--> master --upstream--> origin/master
@end example

Which you prefer is a matter of personal preference.  If you do
prefer the former, then you should add branches such as @code{master},
@code{next}, and @code{maint} to the value of this options.
@end defopt

@defopt magit-branch-adjust-remote-upstream-alist

The value of this option is an alist of branches to be used as
the upstream when branching a remote branch.

When creating a local branch from an ephemeral branch located on a
remote, e.g. a feature or hotfix branch, then that remote branch
should usually not be used as the upstream branch, since the
push-remote already allows accessing it and having both the upstream
and the push-remote reference the same related branch would be
wasteful.  Instead a branch like "maint" or "master" should be used
as the upstream.

This option allows specifing the branch that should be used as the
upstream when branching certain remote branches.  The value is an
alist of the form @code{((UPSTREAM . RULE)...)}.  The first matching
element is used, the following elements are ignored.

UPSTREAM is the branch to be used as the upstream for branches
specified by RULE.  It can be a local or a remote branch.

RULE can either be a regular expression, matching branches whose
upstream should be the one specified by UPSTREAM.  Or it can be a
list of the only branches that should @strong{not} use UPSTREAM; all other
branches will.  Matching is done after stripping the remote part of
the name of the branch that is being branched from.

If you use a finite set of non-ephemeral branches across all your
repositories, then you might use something like:

@lisp
(("origin/master" "master" "next" "maint"))
@end lisp

Or if the names of all your ephemeral branches contain a slash,
at least in some repositories, then a good value could be:

@lisp
(("origin/master" . "/"))
@end lisp

Of course you can also fine-tune:

@lisp
(("origin/maint" . "\\`hotfix/")
 ("origin/master" . "\\`feature/"))
@end lisp
@end defopt

@cindex magit-branch-orphan
@deffn Command magit-branch-orphan

This command creates and checks out a new orphan branch with
contents from a given revision.
@end deffn

@node The Branch Config Popup
@subsection The Branch Config Popup

@cindex magit-branch-popup
@deffn Command magit-branch-popup

This prefix command shows the following branch-related Git variables
in a popup buffer.  The values can be changed from that buffer.

This popup is a sub-popup of several popups that deal with branches,
including @code{magit-branch-popup}, @code{magit-pull-popup}, @code{magit-fetch-popup},
@code{magit-pull-and-fetch-popup}, and @code{magit-push-popup}.  In all of these
popups "C" is bound to this popup.
@end deffn

The following variables are used to configure a specific branch.  The
values are being displayed for the current branch (if any).  To change
the value for another branch invoke @code{magit-branch-config-popup} with a
prefix argument.

@defvar branch.NAME.merge

Together with @code{branch.NAME.remote} this variable defines the upstream
branch of the local branch named NAME.  The value of this variable
is the full reference of the upstream @emph{branch}.
@end defvar

@defvar branch.NAME.remote

Together with @code{branch.NAME.merge} this variable defines the upstream
branch of the local branch named NAME.  The value of this variable
is the name of the upstream @emph{remote}.
@end defvar

@defvar branch.NAME.rebase

This variable controls whether pulling into the branch named NAME is
done by rebasing or by merging the fetched branch.

@itemize
@item
When @code{true} then pulling is done by rebasing.

@item
When @code{false} then pulling is done by merging.

@item
When undefined then the value of @code{pull.rebase} is used.  The default
of that variable is @code{false}.
@end itemize
@end defvar

@defvar branch.NAME.pushRemote

This variable specifies the remote that the branch named NAME is
usually pushed to.  The value has to be the name of an existing
remote.

It is not possible to specify the name of @emph{branch} to push the local
branch to.  The name of the remote branch is always the same as the
name of the local branch.

If this variable is undefined but @code{remote.pushDefault} is defined,
then the value of the latter is used.  By default @code{remote.pushDefault}
is undefined.
@end defvar

@defvar branch.NAME.description

This variable can be used to describe the branch named NAME.  That
description is used e.g. when turning the branch into a series of
patches.
@end defvar

The following variables specify defaults which are used if the above
branch-specific variables are not set.

@defvar pull.rebase

This variable specifies whether pulling is done by rebasing or by
merging.  It can be overwritten using @code{branch.NAME.rebase}.

@itemize
@item
When @code{true} then pulling is done by rebasing.

@item
When @code{false} (the default) then pulling is done by merging.
@end itemize
Since it is never a good idea to merge the upstream branch into a
feature or hotfix branch and most branches are such branches, you
should consider setting this to @code{true}, and @code{branch.master.rebase} to
@code{false}.
@end defvar

@defvar remote.pushDefault

This variable specifies what remote the local branches are usually
pushed to.  This can be overwritten per branch using
@code{branch.NAME.pushRemote}.
@end defvar

The following variables are used during the creation of a branch and
control whether the various branch-specific variables are
automatically set at this time.

@defvar branch.autoSetupMerge

This variable specifies under what circumstances creating a branch
NAME should result in the variables @code{branch.NAME.merge} and
@code{branch.NAME.remote} being set according to the starting point used to
create the branch.  If the starting point isn't a branch, then these
variables are never set.

@itemize
@item
When @code{always} then the variables are set regardless of whether the
starting point is a local or a remote branch.

@item
When @code{true} (the default) then the variables are set when the starting
point is a remote branch, but not when it is a local branch.

@item
When @code{false} then the variables are never set.
@end itemize
@end defvar

@defvar branch.autoSetupRebase

This variable specifies whether creating a branch NAME should result
in the variable @code{branch.NAME.rebase} being set to @code{true}.

@itemize
@item
When @code{always} then the variable is set regardless of whether the
starting point is a local or a remote branch.

@item
When @code{local} then the variable are set when the starting point is a
local branch, but not when it is a remote branch.

@item
When @code{remote} then the variable are set when the starting point is a
remote branch, but not when it is a local branch.

@item
When @code{never} (the default) then the variable is never set.
@end itemize
@end defvar

Note that the respective commands always change the repository-local
values.  If you want to change the global value, which is used when
the local value is undefined, then you have to do so on the command
line, e.g.:

@example
git config --global remote.autoSetupMerge always
@end example

For more information about these variables you should also see

@ifinfo
@ref{git-config,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-config">git-config(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-config(1) manpage.
@end iftex
 Also see 
@ifinfo
@ref{git-branch,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-branch">git-branch(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-branch(1) manpage.
@end iftex
, 
@ifinfo
@ref{git-checkout,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-checkout">git-checkout(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-checkout(1) manpage.
@end iftex
 and @ref{Pushing}.

@defopt magit-prefer-remote-upstream

This option controls whether commands that read a branch from the
user and then set it as the upstream branch, offer a local or a
remote branch as default completion candidate, when they have the
choice.

This affects all commands that use @code{magit-read-upstream-branch} or
@code{magit-read-starting-point}, which includes all commands that change
the upstream and many which create new branches.
@end defopt

@node Merging
@section Merging

Also see 
@ifinfo
@ref{git-merge,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-merge">git-merge(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-merge(1) manpage.
@end iftex
  For information on how to resolve
merge conflicts see the next section.

@table @asis
@kindex m
@cindex magit-merge-popup
@item @kbd{m} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.
@end table

When no merge is in progress, then the popup buffer features the
following commands.

@table @asis
@kindex m m
@cindex magit-merge
@item @kbd{m m} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge})

Merge another branch or an arbitrary revision into the current
branch.  The branch or revision to be merged is read in the
minibuffer and defaults to the one at point.

Unless there are conflicts or a prefix argument is used, the
resulting merge commit uses a generic commit message, and the user
does not get a chance to inspect or change it before the commit is
created.  With a prefix argument this does not actually create the
merge commit, which makes it possible to inspect how conflicts were
resolved and to adjust the commit message.

@kindex m e
@cindex magit-merge-editmsg
@item @kbd{m e} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge-editmsg})

Merge another branch or an arbitrary revision into the current
branch and open a commit message buffer, so that the user can make
adjustments.  The commit is not actually created until the user
finishes with @code{C-c C-c}.

@kindex m n
@cindex magit-merge-nocommit
@item @kbd{m n} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge-nocommit})

Merge another branch or an arbitrary revision into the current
branch, but do not actually create the commit.  The user can then
further adjust the merge, even when automatic conflict resolution
succeeded and/or adjust the commit message.

@kindex m p
@cindex magit-merge-preview
@item @kbd{m p} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge-preview})

Preview result of merging another branch or an arbitrary revision
into the current branch.
@end table

When a merge is in progress, then the popup buffer features these
commands instead.

@table @asis
@kindex m m
@cindex magit-merge
@item @kbd{m m} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge})

After resolving conflicts, proceed with the merge.  If there are
still conflicts, then this fails.

@kindex m a
@cindex magit-merge-abort
@item @kbd{m a} @tie{}@tie{}@tie{}@tie{}(@code{magit-merge-abort})

Abort the current merge operation.
@end table

@node Resolving Conflicts
@section Resolving Conflicts

When merging branches (or otherwise combining or changing history)
conflicts can occur.  If you edited two completely different parts of
the same file in two branches and then merge one of these branches
into the other, then Git can resolve that on its own, but if you edit
the same area of a file, then a human is required to decide how the
two versions, or "sides of the conflict", are to be combined into one.

Here we can only provide a brief introduction to the subject and point
you toward some tools that can help.  If you are new to this, then
please also consult Git's own documentation as well as other
resources.

If a file has conflicts and Git cannot resolve them by itself, then it
puts both versions into the affected file along with special markers
whose purpose is to denote the boundaries of the unresolved part of
the file and between the different versions.  These boundary lines
begin with the strings consisting of six times the same character, one
of @code{<}, @code{|}, @code{=} and @code{>} and are followed by information about the source of
the respective versions, e.g.:

@example
<<<<<<< HEAD
Take the blue pill.
=======
Take the red pill.
>>>>>>> feature
@end example

In this case you have chosen to take the red pill on one branch and on
another you picked the blue pill.  Now that you are merging these two
diverging branches, Git cannot possibly know which pill you want to
take.

To resolve that conflict you have to create a version of the affected
area of the file by keeping only one of the sides, possibly by editing
it in order to bring in the changes from the other side, remove the
other versions as well as the markers, and then stage the result.  A
possible resolution might be:

@example
Take both pills.
@end example

Often it is useful to see not only the two sides of the conflict but
also the "original" version from before the same area of the file was
modified twice on different branches.  Instruct Git to insert that
version as well by running this command once:

@example
git config --global merge.conflictStyle diff3
@end example

The above conflict might then have looked like this:

@example
<<<<<<< HEAD
Take the blue pill.
||||||| merged common ancestors
Take either the blue or the red pill, but not both.
=======
Take the red pill.
>>>>>>> feature
@end example

If that were the case, then the above conflict resolution would not
have been correct, which demonstrates why seeing the original version
alongside the conflicting versions can be useful.

You can perform the conflict resolution completely by hand, but Emacs
also provides some packages that help in the process: Smerge, Ediff
(@ref{Top,,,ediff,}), and Emerge (@ref{Emerge,,,emacs,}).  Magit does not provide
its own tools for conflict resolution, but it does make using Smerge
and Ediff more convenient.  (Ediff supersedes Emerge, so you probably
don't want to use the latter anyway.)

In the Magit status buffer, files with unresolved conflicts are listed
in the "Unstaged changes" and/or "Staged changes" sections.  They are
prefixed with the word "unmerged", which in this context essentially
is a synonym for "unresolved".

Pressing @code{RET} while point is on such a file section shows a buffer
visiting that file, turns on @code{smerge-mode} in that buffer, and places
point inside the first area with conflicts.  You should then resolve
that conflict using regular edit commands and/or Smerge commands.

Unfortunately Smerge does not have a manual, but you can get a list of
commands and binding @code{C-c ^ C-h} and press @code{RET} while point is on a
command name to read its documentation.

Normally you would edit one version and then tell Smerge to keep only
that version.  Use @code{C-c ^ m} (@code{smerge-keep-mine}) to keep the @code{HEAD}
version or @code{C-c ^ o} (@code{smerge-keep-other}) to keep the version that
follows "|||||||".  Then use @code{C-c ^ n} to move to the next conflicting
area in the same file.  Once you are done resolving conflicts, return
to the Magit status buffer.  The file should now be shown as
"modified", no longer as "unmerged", because Smerge automatically
stages the file when you save the buffer after resolving the last
conflict.

Alternatively you could use Ediff, which uses separate buffers for the
different versions of the file.  To resolve conflicts in a file using
Ediff press @code{e} while point is on such a file in the status buffer.

Ediff can be used for other purposes as well.  For more information on
how to enter Ediff from Magit, see @ref{Ediffing}.  Explaining how to use
Ediff is beyond the scope of this manual, instead see @ref{Top,,,ediff,}.

If you are unsure whether you should Smerge or Ediff, then use the
former.  It is much easier to understand and use, and except for
truely complex conflicts, the latter is usually overkill.

@node Rebasing
@section Rebasing

Also see 
@ifinfo
@ref{git-rebase,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-rebase">git-rebase(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-rebase(1) manpage.
@end iftex
  For information on how to resolve
conflicts that occur during rebases see the preceding section.

@table @asis
@kindex r
@cindex magit-rebase-popup
@item @kbd{r} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.
@end table

When no rebase is in progress, then the popup buffer features the
following commands.

Using one of these commands @emph{starts} a rebase sequence.  Git might then
stop somewhere along the way, either because you told it to do so, or
because applying a commit failed due to a conflict.  When that
happens, then the status buffer shows information about the rebase
sequence which is in progress in a section similar to a log section.
See @ref{Information About In-Progress Rebase}.

@table @asis
@kindex r p
@cindex magit-rebase-onto-pushremote
@item @kbd{r p} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-onto-pushremote})

Rebase the current branch onto @code{branch.<name>.pushRemote}.  If that
variable is unset, then rebase onto @code{remote.pushDefault}.

@kindex r u
@cindex magit-rebase-onto-upstream
@item @kbd{r u} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-onto-upstream})

Rebase the current branch onto its upstream branch.

@kindex r e
@cindex magit-rebase
@item @kbd{r e} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase})

Rebase the current branch onto a branch read in the minibuffer.  All
commits that are reachable from head but not from the selected
branch TARGET are being rebased."

@kindex r s
@cindex magit-rebase-subset
@item @kbd{r s} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-subset})

Start a non-interactive rebase sequence with commits from START to
@code{HEAD} onto NEWBASE.  START has to be selected from a list of recent
commits.
@end table

Note that the popup also features the infix argument @code{--interactive}.
This can be used to turn one of the above non-interactive rebase
variants into an interactive rebase.

For example if you want to clean up a feature branch and at the same
time rebase it onto @code{master}, then you could use @code{r-iu}.  But we recommend
that you instead do that in two steps.  First use @code{ri} to cleanup the
feature branch, and then in a second step @code{ru} to rebase it onto @code{master}.
That way if things turn out to be more complicated than you thought
and/or you make a mistake and have to start over, then you only have
to redo half the work.

Explicitly enabling @code{--interactive} won't have an effect on the
following commands as they always use that argument anyway, even if it
is not enabled in the popup.

@table @asis
@kindex r i
@cindex magit-rebase-interactive
@item @kbd{r i} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-interactive})

Start an interactive rebase sequence.

@kindex r f
@cindex magit-rebase-autosquash
@item @kbd{r f} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-autosquash})

Combine squash and fixup commits with their intended targets.

@kindex r m
@cindex magit-rebase-edit-commit
@item @kbd{r m} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-edit-commit})

Edit a single older commit using rebase.

@kindex r w
@cindex magit-rebase-reword-commit
@item @kbd{r w} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-reword-commit})

Reword a single older commit using rebase.
@end table

When a rebase is in progress, then the popup buffer features these
commands instead.

@table @asis
@kindex r r
@cindex magit-rebase-continue
@item @kbd{r r} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-continue})

Restart the current rebasing operation.

In some cases this pops up a commit message buffer for you do edit.
With a prefix argument the old message is reused as-is.

@kindex r s
@cindex magit-rebase-skip
@item @kbd{r s} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-skip})

Skip the current commit and restart the current rebase operation.

@kindex r e
@cindex magit-rebase-edit
@item @kbd{r e} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-edit})

Edit the todo list of the current rebase operation.

@kindex r a
@cindex magit-rebase-abort
@item @kbd{r a} @tie{}@tie{}@tie{}@tie{}(@code{magit-rebase-abort})

Abort the current rebase operation, restoring the original branch.
@end table

@menu
* Editing Rebase Sequences::
* Information About In-Progress Rebase::
@end menu

@node Editing Rebase Sequences
@subsection Editing Rebase Sequences

@table @asis
@kindex C-c C-c
@cindex with-editor-finish
@item @kbd{C-c C-c} @tie{}@tie{}@tie{}@tie{}(@code{with-editor-finish})

Finish the current editing session by returning with exit code 0.
Git then uses the rebase instructions it finds in the file.

@kindex C-c C-k
@cindex with-editor-cancel
@item @kbd{C-c C-k} @tie{}@tie{}@tie{}@tie{}(@code{with-editor-cancel})

Cancel the current editing session by returning with exit code 1.
Git then forgoes starting the rebase sequence.

@kindex RET
@cindex git-rebase-show-commit
@item @kbd{RET} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-show-commit})

Show the commit on the current line in another buffer and select
that buffer.

@kindex SPC
@cindex git-rebase-show-or-scroll-up
@item @kbd{SPC} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-show-or-scroll-up})

Show the commit on the current line in another buffer without
selecting that buffer.  If the revision buffer is already visible in
another window of the current frame, then instead scroll that window
up.

@kindex DEL
@cindex git-rebase-show-or-scroll-down
@item @kbd{DEL} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-show-or-scroll-down})

Show the commit on the current line in another buffer without
selecting that buffer.  If the revision buffer is already visible in
another window of the current frame, then instead scroll that window
down.

@kindex p
@cindex git-rebase-backward-line
@item @kbd{p} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-backward-line})

Move to previous line.

@kindex n
@cindex forward-line
@item @kbd{n} @tie{}@tie{}@tie{}@tie{}(@code{forward-line})

Move to next line.

@kindex M-p
@cindex git-rebase-move-line-up
@item @kbd{M-p} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-move-line-up})

Move the current commit (or command) up.

@kindex M-n
@cindex git-rebase-move-line-down
@item @kbd{M-n} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-move-line-down})

Move the current commit (or command) down.

@kindex r
@cindex git-rebase-reword
@item @kbd{r} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-reword})

Edit message of commit on current line.

@kindex e
@cindex git-rebase-edit
@item @kbd{e} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-edit})

Stop at the commit on the current line.

@kindex s
@cindex git-rebase-squash
@item @kbd{s} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-squash})

Meld commit on current line into previous commit, and edit message.

@kindex f
@cindex git-rebase-fixup
@item @kbd{f} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-fixup})

Meld commit on current line into previous commit, discarding the
current commit's message.

@kindex k
@cindex git-rebase-kill-line
@item @kbd{k} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-kill-line})

Kill the current action line.

@kindex c
@cindex git-rebase-pick
@item @kbd{c} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-pick})

Use commit on current line.

@kindex x
@cindex git-rebase-exec
@item @kbd{x} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-exec})

Insert a shell command to be run after the proceeding commit.

If there already is such a command on the current line, then edit
that instead.  With a prefix argument insert a new command even when
there already is one on the current line.  With empty input remove
the command on the current line, if any.

@kindex y
@cindex git-rebase-insert
@item @kbd{y} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-insert})

Read an arbitrary commit and insert it below current line.

@kindex C-x u
@cindex git-rebase-undo
@item @kbd{C-x u} @tie{}@tie{}@tie{}@tie{}(@code{git-rebase-undo})

Undo some previous changes.  Like @code{undo} but works in read-only
buffers.

@end table

@defopt git-rebase-auto-advance

Whether to move to next line after changing a line.
@end defopt

@defopt git-rebase-show-instructions

Whether to show usage instructions inside the rebase buffer.
@end defopt

@defopt git-rebase-confirm-cancel

Whether confirmation is required to cancel.
@end defopt

@node Information About In-Progress Rebase
@subsection Information About In-Progress Rebase

While a rebase sequence is in progress, the status buffer features a
section which lists the commits that have already been applied as well
as the commits that still have to be applied.

The commits are split in two halves.  When rebase stops at a commit,
either because the user has to deal with a conflict or explicitly
requested that rebase stops at that commit, then point is placed on
the commit that separates the two groups, i.e. on @code{HEAD}.  The commits
above it have not been applied yet, while it and the commits below it
have already been applied.  In between these two groups of applied and
yet-to-be applied commits, there sometimes is a commit which has been
dropped.

Each commit is prefixed with a word and these words are additionally
shown in different colors to indicate the status of the commits.

The following colors are used:

@itemize
@item
Yellow commits have not been applied yet.


@item
Gray commits have already been applied.


@item
The blue commit is the @code{HEAD} commit.


@item
The green commit is the commit the rebase sequence stopped at.  If
this is the same commit as @code{HEAD} (e.g. because you haven't done
anything yet after rebase stopped at the commit, then this commit is
shown in blue, not green.  There can only be a green and a blue
commit at the same time, if you create one or more new commits after
rebase stops at a commit.


@item
Red commits have been dropped.  They are shown for reference only,
e.g. to make it easier to diff.
@end itemize

Of course these colors are subject to the color-theme in use.

The following words are used:

@itemize
@item
Commits prefixed with @code{pick}, @code{reword}, @code{edit}, @code{squash}, and @code{fixup} have not
been applied yet.  These words have the same meaning here as they do
in the buffer used to edit the rebase sequence.  See @ref{Editing Rebase Sequences}.


@item
The commit prefixed with @code{onto} is the commit on top of which all the
other commits are being re-applied.  Like the commits that have
already been re-applied, it is reachable from @code{HEAD}, but unlike those
it has not actually been re-applied during the current session - it
wasn't touched at all.


@item
Commits prefixed with @code{done} have already been re-applied.  Not all
commits that have already been applied are prefixed with this word,
though.


@item
When a commit is prefixed with @code{void}, then that indicates that Magit
knows for sure that all the changes in that commit have been applied
using several new commits.  This commit is no longer reachable from
@code{HEAD}, and it also isn't one of the commits that will be applied when
resuming the session.


@item
When a commit is prefixed with @code{join}, then that indicates that the
rebase sequence stopped at that commit due to a conflict - you now
have to join (merge) the changes with what has already been
applied.  In a sense this is the commit rebase stopped at, but while
its effect is already in the index and in the worktree (with
conflict markers), the commit itself has not actually been applied
yet (it isn't the @code{HEAD}).  So it is shown in yellow, like the other
commits that still have to be applied.


@item
When a commit is prefixed with @code{goal}, @code{same}, or @code{work}, then that
indicates that you reset to an earlier commit (and that this commit
therefore is no longer reachable from @code{HEAD}), but that it might still
be possible to create a new commit with the exact same tree or at
least the same patch-id @footnote{The patch-id is a hash of the @emph{changes} introduced by
commit.  It differs from hash of the commit itself, which is a hash of
the result of applying that change (i.e. the resulting trees and
blobs) as well as author and committer information, the commit
message, and the hashes of the parents of the commit.  The patch-id
hash on the other hand is created only from the added and removed
lines, even line numbers and whitespace are created when calculating
the hash.  The patch-ids of two commits can be used to answer the
question "Do these two commits make the same change?".}, without manually editing any
file.  Or at the very least that there are some uncommitted
remaining, which may or may not originate from that commit.

@itemize
@item
When a commit is prefixed with @code{goal}, then that indicates that it
is still possible to create a commit with the exact same tree
(the "goal") without manually editing a file, by simply committing
the index (or, provided nothing is already staged, by staging all
unstaged changes and then committing that).  This is the case when
the original tree exists in the index or worktree in untainted
form.


@item
When a commit is prefixed with @code{same}, then that indicates that it
is no longer possible to create a commit with the exact same tree,
but that it is still possible to create a commit with the same
patch-id.  This would be the case if you created a new commit with
other changes, but the changes from the original commit still
exist in the index and/or working tree in untainted form.


@item
When a commit is prefixed with @code{work}, then that indicates that you
are working with the changes from that commit after resetting to
an earlier commit.  There are changes in the index and/or working
tree and some of them likely originate from that commit.
@end itemize


@item
When a commit is prefixed with @code{poof} or @code{gone}, then that indicates
that you reset to an earlier commit (and that this commit therefore
is no longer reachable from @code{HEAD}), and that there are no
uncommitted changes remaining which might allow you to create a new
commit with the same tree or at least the same patch-id.

@itemize
@item
When a commit is prefixed with @code{poof}, then that indicates that it
is no longer reachable from @code{HEAD}, but that it has been replaced
with one or more commits, which together have the exact same
effect.


@item
When a commit is prefixed with @code{gone}, then that indicates that it
is no longer reachable from @code{HEAD} and that we also cannot determine
whether its changes are still in effect in one or more new
commits.  They might be, but if so, then there must also be other
changes which makes it impossible to know for sure.
@end itemize
@end itemize

Do not worry if you do not fully understand the above.  That's okay,
you will acquire a good enough understanding through practice.

For other sequence operations such as cherry-picking, a similar section
is displayed, but they lack some of the features described above, due
to limitations in the git commands used to implement them.  Most
importantly these sequences only support "picking" a commit but not
other actions such as "rewording", and they do not keep track of the
commits which have already been applied.

@node Cherry Picking
@section Cherry Picking

Also see 
@ifinfo
@ref{git-cherry-pick,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-cherry-pick">git-cherry-pick(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-cherry-pick(1) manpage.
@end iftex

@table @asis
@kindex A
@cindex magit-cherry-pick-popup
@item @kbd{A} @tie{}@tie{}@tie{}@tie{}(@code{magit-cherry-pick-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.
@end table

When no cherry-pick or revert is in progress, then the popup buffer
features the following commands.

@table @asis
@kindex A A
@cindex magit-cherry-pick
@item @kbd{A A} @tie{}@tie{}@tie{}@tie{}(@code{magit-cherry-pick})

Cherry-pick a commit.  Prompt for a commit, defaulting to the commit
at point.  If the region selects multiple commits, then pick all of
them, without prompting.

@kindex A a
@cindex magit-cherry-apply
@item @kbd{A a} @tie{}@tie{}@tie{}@tie{}(@code{magit-cherry-apply})

Apply the changes in a commit to the working tree, but do not commit
them.  Prompt for a commit, defaulting to the commit at point.  If
the region selects multiple commits, then apply all of them, without
prompting.

This command also has a top-level binding, which can be invoked without
using the popup by typing @code{a} at the top-level.
@end table

When a cherry-pick or revert is in progress, then the popup buffer
features these commands instead.

@table @asis
@kindex A A
@cindex magit-sequence-continue
@item @kbd{A A} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-continue})

Resume the current cherry-pick or revert sequence.

@kindex A s
@cindex magit-sequence-skip
@item @kbd{A s} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-skip})

Skip the stopped at commit during a cherry-pick or revert sequence.

@kindex A a
@cindex magit-sequence-abort
@item @kbd{A a} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-abort})

Abort the current cherry-pick or revert sequence.  This discards all
changes made since the sequence started.
@end table

@menu
* Reverting::
@end menu

@node Reverting
@subsection Reverting

@table @asis
@kindex V
@cindex magit-revert-popup
@item @kbd{V} @tie{}@tie{}@tie{}@tie{}(@code{magit-revert-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.
@end table

When no cherry-pick or revert is in progress, then the popup buffer
features the following commands.

@table @asis
@kindex V V
@cindex magit-revert
@item @kbd{V V} @tie{}@tie{}@tie{}@tie{}(@code{magit-revert})

Revert a commit by creating a new commit.  Prompt for a commit,
defaulting to the commit at point.  If the region selects multiple
commits, then revert all of them, without prompting.

@kindex V v
@cindex magit-revert-no-commit
@item @kbd{V v} @tie{}@tie{}@tie{}@tie{}(@code{magit-revert-no-commit})

Revert a commit by applying it in reverse to the working tree.
Prompt for a commit, defaulting to the commit at point.  If the
region selects multiple commits, then revert all of them, without
prompting.
@end table

When a cherry-pick or revert is in progress, then the popup buffer
features these commands instead.

@table @asis
@kindex V A
@cindex magit-sequence-continue
@item @kbd{V A} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-continue})

Resume the current cherry-pick or revert sequence.

@kindex V s
@cindex magit-sequence-skip
@item @kbd{V s} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-skip})

Skip the stopped at commit during a cherry-pick or revert sequence.

@kindex V a
@cindex magit-sequence-abort
@item @kbd{V a} @tie{}@tie{}@tie{}@tie{}(@code{magit-sequence-abort})

Abort the current cherry-pick or revert sequence.  This discards all
changes made since the sequence started.
@end table

@node Resetting
@section Resetting

Also see 
@ifinfo
@ref{git-reset,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-reset">git-reset(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-reset(1) manpage.
@end iftex

@table @asis
@kindex x
@cindex magit-reset
@item @kbd{x} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset})

Reset the head and index to some commit read from the user and
defaulting to the commit at point.  The working tree is kept as-is.
With a prefix argument also reset the working tree.

@kindex X m
@cindex magit-reset-head
@item @kbd{X m} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset-head})

Reset the @code{HEAD} and index to some commit read from the user and
defaulting to the commit at point.  The working tree is kept as-is.

@kindex X s
@cindex magit-reset-soft
@item @kbd{X s} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset-soft})

Reset the @code{HEAD} to some commit read from the user and defaulting
to the commit at point.  The index and the working tree are kept
as-is.

@kindex X h
@cindex magit-reset-hard
@item @kbd{X h} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset-hard})

Reset the @code{HEAD}, index, and working tree to some commit read from the
user and defaulting to the commit at point.

@kindex X i
@cindex magit-reset-index
@item @kbd{X i} @tie{}@tie{}@tie{}@tie{}(@code{magit-reset-index})

Reset the index to some commit read from the user and defaulting to
the commit at point.  Keep the @code{HEAD} and working tree as-is, so if
the commit refers to the @code{HEAD}, then this effectively unstages all
changes.

@kindex X f
@cindex magit-file-checkout
@item @kbd{X f} @tie{}@tie{}@tie{}@tie{}(@code{magit-file-checkout})

Update file in the working tree and index to the contents from a
revision.  Both the revision and file are read from the user.
@end table

@node Stashing
@section Stashing

Also see 
@ifinfo
@ref{git-stash,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-stash">git-stash(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-stash(1) manpage.
@end iftex

@table @asis
@kindex z
@cindex magit-stash-popup
@item @kbd{z} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex z z
@cindex magit-stash
@item @kbd{z z} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash})

Create a stash of the index and working tree.  Untracked files are
included according to popup arguments.  One prefix argument is
equivalent to @code{--include-untracked} while two prefix arguments are
equivalent to @code{--all}.

@kindex z i
@cindex magit-stash-index
@item @kbd{z i} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-index})

Create a stash of the index only.  Unstaged and untracked changes
are not stashed.

@kindex z w
@cindex magit-stash-worktree
@item @kbd{z w} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-worktree})

Create a stash of unstaged changes in the working tree.  Untracked
files are included according to popup arguments.  One prefix
argument is equivalent to @code{--include-untracked} while two prefix
arguments are equivalent to @code{--all}.

@kindex z x
@cindex magit-stash-keep-index
@item @kbd{z x} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-keep-index})

Create a stash of the index and working tree, keeping index intact.
Untracked files are included according to popup arguments.  One
prefix argument is equivalent to @code{--include-untracked} while two
prefix arguments are equivalent to @code{--all}.

@kindex z Z
@cindex magit-snapshot
@item @kbd{z Z} @tie{}@tie{}@tie{}@tie{}(@code{magit-snapshot})

Create a snapshot of the index and working tree.  Untracked files
are included according to popup arguments.  One prefix argument is
equivalent to @code{--include-untracked} while two prefix arguments are
equivalent to @code{--all}.

@kindex z I
@cindex magit-snapshot-index
@item @kbd{z I} @tie{}@tie{}@tie{}@tie{}(@code{magit-snapshot-index})

Create a snapshot of the index only.  Unstaged and untracked changes
are not stashed.

@kindex z W
@cindex magit-snapshot-worktree
@item @kbd{z W} @tie{}@tie{}@tie{}@tie{}(@code{magit-snapshot-worktree})

Create a snapshot of unstaged changes in the working tree.
Untracked files are included according to popup arguments.  One
prefix argument is equivalent to @code{--include-untracked} while two
prefix arguments are equivalent to @code{--all}-.

@kindex z a
@cindex magit-stash-apply
@item @kbd{z a} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-apply})

Apply a stash to the working tree.  Try to preserve the stash index.
If that fails because there are staged changes, apply without
preserving the stash index.

@kindex z p
@cindex magit-stash-pop
@item @kbd{z p} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-pop})

Apply a stash to the working tree and remove it from stash list.
Try to preserve the stash index.  If that fails because there are
staged changes, apply without preserving the stash index and forgo
removing the stash.

@kindex z k
@cindex magit-stash-drop
@item @kbd{z k} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-drop})

Remove a stash from the stash list.  When the region is active, offer
to drop all contained stashes.

@kindex z v
@cindex magit-stash-show
@item @kbd{z v} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-show})

Show all diffs of a stash in a buffer.

@kindex z b
@cindex magit-stash-branch
@item @kbd{z b} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-branch})

Create and checkout a new BRANCH from STASH.

@kindex z f
@cindex magit-stash-format-patch
@item @kbd{z f} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-format-patch})

Create a patch from STASH.

@kindex k
@cindex magit-stash-clear
@item @kbd{k} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-clear})

Remove all stashes saved in REF's reflog by deleting REF.

@kindex z l
@cindex magit-stash-list
@item @kbd{z l} @tie{}@tie{}@tie{}@tie{}(@code{magit-stash-list})

List all stashes in a buffer.

@end table

@defopt magit-stashes-margin

This option specifies whether the margin is initially shown in
stashes buffers and how it is formatted.

The value has the form @code{(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)}.

@itemize
@item
If INIT is non-nil, then the margin is shown initially.

@item
STYLE controls how to format the committer date.  It can be one
of @code{age} (to show the age of the commit), @code{age-abbreviated} (to
abbreviate the time unit to a character), or a string (suitable
for @code{format-time-string}) to show the actual date.

@item
WIDTH controls the width of the margin.  This exists for forward
compatibility and currently the value should not be changed.

@item
AUTHOR controls whether the name of the author is also shown by
default.

@item
AUTHOR-WIDTH has to be an integer.  When the name of the author
is shown, then this specifies how much space is used to do so.
@end itemize
@end defopt

@node Transferring
@chapter Transferring

@menu
* Remotes::
* Fetching::
* Pulling::
* Pushing::
* Creating and Sending Patches::
* Applying Patches::
@end menu

@node Remotes
@section Remotes

Also see 
@ifinfo
@ref{git-remote,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-remote">git-remote(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-remote(1) manpage.
@end iftex

@table @asis
@kindex M
@cindex magit-remote-popup
@item @kbd{M} @tie{}@tie{}@tie{}@tie{}(@code{magit-remote-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex M a
@cindex magit-remote-add
@item @kbd{M a} @tie{}@tie{}@tie{}@tie{}(@code{magit-remote-add})

Add a remote and fetch it.  The remote name and url are read in the
minibuffer.

@kindex M r
@cindex magit-remote-rename
@item @kbd{M r} @tie{}@tie{}@tie{}@tie{}(@code{magit-remote-rename})

Rename a remote.  Both the old and the new names are read in the
minibuffer.

@kindex M u
@cindex magit-remote-set-url
@item @kbd{M u} @tie{}@tie{}@tie{}@tie{}(@code{magit-remote-set-url})

Change the url of a remote.  Both the remote and the new url are
read in the minibuffer.

@kindex M k
@cindex magit-remote-remove
@item @kbd{M k} @tie{}@tie{}@tie{}@tie{}(@code{magit-remote-remove})

Delete a remote, read from the minibuffer.

@end table

@defopt magit-remote-add-set-remote.pushDefault

Whether to set the value of @code{remote.pushDefault} after adding a
remote.

If @code{ask}, then always ask.  If @code{ask-if-unset}, then ask, but only if the
variable isn't set already.  If @code{nil}, then don't ever set.  If the value
is a string, then set without asking, provided that the name of the added
remote is equal to that string and the variable isn't already set.
@end defopt

@node Fetching
@section Fetching

For information about the differences between the @emph{upstream} and the
@emph{push-remote}, see @ref{Branching}.

Also see 
@ifinfo
@ref{git-fetch,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-fetch">git-fetch(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-fetch(1) manpage.
@end iftex

@table @asis
@kindex f
@cindex magit-fetch-popup
@item @kbd{f} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex f p
@cindex magit-fetch-from-pushremote
@item @kbd{f p} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-from-pushremote})

Fetch from the push-remote of the current branch.

@kindex f u
@cindex magit-fetch-from-upstream
@item @kbd{f u} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-from-upstream})

Fetch from the upstream of the current branch.

@kindex f e
@cindex magit-fetch
@item @kbd{f e} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch})

Fetch from another repository.

@kindex f o
@cindex magit-fetch-branch
@item @kbd{f o} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-branch})

Fetch a branch from a remote, both of which are read from the
minibuffer.

@kindex f r
@cindex magit-fetch-refspec
@item @kbd{f r} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-refspec})

Fetch from a remote using an explicit refspec, both of which are
read from the minibuffer.

@kindex f a
@cindex magit-fetch-all
@item @kbd{f a} @tie{}@tie{}@tie{}@tie{}(@code{magit-fetch-all})

Fetch from all remotes.

@kindex f m
@cindex magit-submodule-fetch
@item @kbd{f m} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-fetch})

Fetch all submodules.  With a prefix argument fetch all remotes of
all submodules.
@end table

Instead of using one popup for fetching and another for pulling, you
could also use @code{magit-pull-and-fetch-popup}.  See its doc-string for
more information.

@node Pulling
@section Pulling

For information about the differences between the @emph{upstream} and the
@emph{push-remote}, see @ref{Branching}.

Also see 
@ifinfo
@ref{git-pull,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-pull">git-pull(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-pull(1) manpage.
@end iftex

@table @asis
@kindex F
@cindex magit-pull-popup
@item @kbd{F} @tie{}@tie{}@tie{}@tie{}(@code{magit-pull-popup})

This prefix command shows the following suffix commands in a popup
buffer.

@kindex F p
@cindex magit-pull-from-pushremote
@item @kbd{F p} @tie{}@tie{}@tie{}@tie{}(@code{magit-pull-from-pushremote})

Pull from the push-remote of the current branch.

@kindex F u
@cindex magit-pull-from-upstream
@item @kbd{F u} @tie{}@tie{}@tie{}@tie{}(@code{magit-pull-from-upstream})

Pull from the upstream of the current branch.

@kindex F e
@cindex magit-pull
@item @kbd{F e} @tie{}@tie{}@tie{}@tie{}(@code{magit-pull})

Pull from a branch read in the minibuffer.
@end table

Instead of using one popup for fetching and another for pulling, you
could also use @code{magit-pull-and-fetch-popup}.  See its doc-string for
more information.

@node Pushing
@section Pushing

For information about the differences between the @emph{upstream} and the
@emph{push-remote}, see @ref{Branching}.

Also see 
@ifinfo
@ref{git-push,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-push">git-push(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-push(1) manpage.
@end iftex

@table @asis
@kindex P
@cindex magit-push-popup
@item @kbd{P} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex P p
@cindex magit-push-current-to-pushremote
@item @kbd{P p} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-current-to-pushremote})

Push the current branch to @code{branch.<name>.pushRemote} or if that
is unset to @code{remote.pushDefault}.

When @code{magit-push-current-set-remote-if-missing} is non-nil and the
push-remote is not configured, then read the push-remote from the
user, set it, and then push to it.  With a prefix argument the
push-remote can be changed before pushed to it.

@kindex P u
@cindex magit-push-current-to-upstream
@item @kbd{P u} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-current-to-upstream})

Push the current branch to its upstream branch.

When @code{magit-push-current-set-remote-if-missing} is non-nil and the
push-remote is not configured, then read the upstram from the
user, set it, and then push to it.  With a prefix argument the
push-remote can be changed before pushed to it.

@kindex P e
@cindex magit-push-current
@item @kbd{P e} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-current})

Push the current branch to a branch read in the minibuffer.

@kindex P o
@cindex magit-push
@item @kbd{P o} @tie{}@tie{}@tie{}@tie{}(@code{magit-push})

Push an arbitrary branch or commit somewhere.  Both the source and
the target are read in the minibuffer.

@kindex P r
@cindex magit-push-refspecs
@item @kbd{P r} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-refspecs})

Push one or multiple refspecs to a remote, both of which are read
in the minibuffer.

To use multiple refspecs, separate them with commas.  Completion is
only available for the part before the colon, or when no colon is
used.

@kindex P m
@cindex magit-push-matching
@item @kbd{P m} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-matching})

Push all matching branches to another repository.  If multiple
remotes exit, then read one from the user.  If just one exists, use
that without requiring confirmation.

@kindex P t
@cindex magit-push-tags
@item @kbd{P t} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-tags})

Push all tags to another repository.  If only one remote exists,
then push to that.  Otherwise prompt for a remote, offering the
remote configured for the current branch as default.

@kindex P T
@cindex magit-push-tag
@item @kbd{P T} @tie{}@tie{}@tie{}@tie{}(@code{magit-push-tag})

Push a tag to another repository.
@end table

Two more push commands exist, which by default are not available from
the push popup.  See their doc-strings for instructions on how to add
them to the popup.

@cindex magit-push-implicitly args
@deffn Command magit-push-implicitly args

Push somewhere without using an explicit refspec.

This command simply runs @code{git push -v [ARGS]}.  ARGS are the arguments
specified in the popup buffer.  No explicit refspec arguments are
used.  Instead the behavior depends on at least these Git variables:
@code{push.default}, @code{remote.pushDefault}, @code{branch.<branch>.pushRemote},
@code{branch.<branch>.remote}, @code{branch.<branch>.merge}, and
@code{remote.<remote>.push}.
@end deffn

@cindex magit-push-to-remote remote args
@deffn Command magit-push-to-remote remote args

Push to the remote REMOTE without using an explicit refspec.  The
remote is read in the minibuffer.

This command simply runs @code{git push -v [ARGS] REMOTE}.  ARGS are the
arguments specified in the popup buffer.  No refspec arguments are
used.  Instead the behavior depends on at least these Git variables:
@code{push.default}, @code{remote.pushDefault}, @code{branch.<branch>.pushRemote},
@code{branch.<branch>.remote}, @code{branch.<branch>.merge}, and
@code{remote.<remote>.push}.
@end deffn

@defopt magit-push-current-set-remote-if-missing

This option controls whether missing remotes are configured before
pushing.

When @code{nil}, then the command @code{magit-push-current-to-pushremote} and
@code{magit-push-current-to-upstream} do not appear in the push popup if
the push-remote resp. upstream is not configured.  If the user
invokes one of these commands anyway, then it raises an error.

When @code{non-nil}, then these commands always appear in the push popup.
But if the required configuration is missing, then they do appear in
a way that indicates that this is the case.  If the user invokes one
of them, then it asks for the necessary configuration, stores the
configuration, and then uses it to push a first time.

This option also affects whether the argument @code{--set-upstream} is
available in the popup.  If the value is @code{non-nil}, then that argument
is redundant.  But note that changing the value of this option does
not take affect immediately, the argument will only be added or
removed after restarting Emacs.
@end defopt

@node Creating and Sending Patches
@section Creating and Sending Patches

@table @asis
@kindex W
@cindex magit-patch-popup
@item @kbd{W} @tie{}@tie{}@tie{}@tie{}(@code{magit-patch-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex W p
@cindex magit-format-patch
@item @kbd{W p} @tie{}@tie{}@tie{}@tie{}(@code{magit-format-patch})

Create patches for a set commits.  If the region marks commits, then
create patches for those.  Otherwise prompt for a range or a single
commit, defaulting to the commit at point.

@kindex W r
@cindex magit-request-pull
@item @kbd{W r} @tie{}@tie{}@tie{}@tie{}(@code{magit-request-pull})

Request that upstream pulls from your public repository.
@end table

@node Applying Patches
@section Applying Patches

Also see 
@ifinfo
@ref{git-am,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-am">git-am(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-am(1) manpage.
@end iftex

@table @asis
@kindex w
@cindex magit-am-popup
@item @kbd{w} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex w w
@cindex magit-am-apply-patches
@item @kbd{w w} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-apply-patches})

Apply one or more patches.  If the region marks files, then apply
those patches.  Otherwise read a file name in the minibuffer
defaulting to the file at point.

@kindex w m
@cindex magit-am-apply-maildir
@item @kbd{w m} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-apply-maildir})

Apply the patches from a maildir.

@kindex w w
@cindex magit-am-continue
@item @kbd{w w} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-continue})

Resume the current patch applying sequence.

@kindex w s
@cindex magit-am-skip
@item @kbd{w s} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-skip})

Skip the stopped at patch during a patch applying sequence.

@kindex w a
@cindex magit-am-abort
@item @kbd{w a} @tie{}@tie{}@tie{}@tie{}(@code{magit-am-abort})

Abort the current patch applying sequence.  This discards all
changes made since the sequence started.
@end table

@node Miscellaneous
@chapter Miscellaneous

@menu
* Tagging::
* Notes::
* Submodules::
* Subtree::
* Common Commands::
* Wip Modes::
* Minor Mode for Buffers Visiting Files::
* Minor Mode for Buffers Visiting Blobs::
@end menu

@node Tagging
@section Tagging

Also see 
@ifinfo
@ref{git-tag,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-tag">git-tag(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-tag(1) manpage.
@end iftex

@table @asis
@kindex t
@cindex magit-tag-popup
@item @kbd{t} @tie{}@tie{}@tie{}@tie{}(@code{magit-tag-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex t t
@cindex magit-tag
@item @kbd{t t} @tie{}@tie{}@tie{}@tie{}(@code{magit-tag})

Create a new tag with the given NAME at REV.  With a prefix argument
annotate the tag.

@kindex t k
@cindex magit-tag-delete
@item @kbd{t k} @tie{}@tie{}@tie{}@tie{}(@code{magit-tag-delete})

Delete one or more tags.  If the region marks multiple tags (and
nothing else), then offer to delete those.  Otherwise, prompt for a
single tag to be deleted, defaulting to the tag at point.

@kindex t p
@cindex magit-tag-prune
@item @kbd{t p} @tie{}@tie{}@tie{}@tie{}(@code{magit-tag-prune})

Offer to delete tags missing locally from REMOTE, and vice versa.
@end table

@node Notes
@section Notes

Also see 
@ifinfo
@ref{git-notes,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-notes">git-notes(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-notes(1) manpage.
@end iftex

@table @asis
@kindex T
@cindex magit-notes-popup
@item @kbd{T} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex T T
@cindex magit-notes-edit
@item @kbd{T T} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-edit})

Edit the note attached to a commit, defaulting to the commit at
point.

By default use the value of Git variable @code{core.notesRef} or
"refs/notes/commits" if that is undefined.

@kindex T r
@cindex magit-notes-remove
@item @kbd{T r} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-remove})

Remove the note attached to a commit, defaulting to the commit at
point.

By default use the value of Git variable @code{core.notesRef} or
"refs/notes/commits" if that is undefined.

@kindex T p
@cindex magit-notes-prune
@item @kbd{T p} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-prune})

Remove notes about unreachable commits.

@kindex T s
@cindex magit-notes-set-ref
@item @kbd{T s} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-set-ref})

Set the current notes ref to a the value read from the user.  The
ref is made current by setting the value of the Git variable
@code{core.notesRef}.  With a prefix argument change the global value
instead of the value in the current repository.  When this is
undefined, then "refs/notes/commit" is used.

Other @code{magit-notes-*} commands, as well as the sub-commands of Git's
@code{note} command, default to operate on that ref.

@kindex T S
@cindex magit-notes-set-display-refs
@item @kbd{T S} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-set-display-refs})

Set notes refs to be display in addition to "core.notesRef".  This
reads a colon separated list of notes refs from the user.  The
values are stored in the Git variable @code{notes.displayRef}.  With a
prefix argument GLOBAL change the global values instead of the
values in the current repository.
@end table

It is possible to merge one note ref into another.  That may result in
conflicts which have to resolved in the temporary worktree
".git/NOTES@math{_MERGE}@math{_WORKTREE}".

@table @asis
@kindex T m
@cindex magit-notes-merge
@item @kbd{T m} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-merge})

Merge the notes of a ref read from the user into the current notes
ref.  The current notes ref is the value of Git variable
@code{core.notesRef} or "refs/notes/commits" if that is undefined.
@end table

When a notes merge is in progress then the popup features the
following suffix commands, instead of those listed above.

@table @asis
@kindex T c
@cindex magit-notes-merge-commit
@item @kbd{T c} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-merge-commit})

Commit the current notes ref merge, after manually resolving
conflicts.

@kindex T a
@cindex magit-notes-merge-abort
@item @kbd{T a} @tie{}@tie{}@tie{}@tie{}(@code{magit-notes-merge-abort})

Abort the current notes ref merge.
@end table

@node Submodules
@section Submodules

Also see 
@ifinfo
@ref{git-submodule,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-submodule">git-submodule(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-submodule(1) manpage.
@end iftex

@menu
* Listing Submodules::
* Submodule Popup::
@end menu

@node Listing Submodules
@subsection Listing Submodules

The command @code{magit-list-submodules} displays a list of the current
repository's submodules in a separate buffer.  It's also possible to
display information about submodules directly in the status buffer of
the super-repository by adding @code{magit-insert-submodules} to the hook
@code{magit-status-sections-hook}.

@cindex magit-list-submodules
@deffn Command magit-list-submodules

This command displays a list of the current repository's submodules
in a separate buffer.

It can be invoked by pressing @code{RET} on the section titled "Modules".
@end deffn

@defopt magit-submodule-list-columns

This option controls what columns are displayed by the command
@code{magit-list-submodules} and how they are displayed.

Each element has the form @code{(HEADER WIDTH FORMAT PROPS)}.

HEADER is the string displayed in the header.  WIDTH is the width of
the column.  FORMAT is a function that is called with one argument,
the repository identification (usually its basename), and with
@code{default-directory} bound to the toplevel of its working tree.  It
has to return a string to be inserted or nil.  PROPS is an alist
that supports the keys @code{:right-align} and @code{:pad-right}.
@end defopt

@defun magit-insert-submodules

Insert sections for all submodules.  For each section insert the
path, the branch, and the output of @code{git describe --tags}.

Press @code{RET} on such a submodule section to show its own status buffer.
Press @code{RET} on the "Modules" section to display a list of submodules
in a separate buffer.  This shows additional information not
displayed in the super-repository's status buffer.
@end defun

@node Submodule Popup
@subsection Submodule Popup

@table @asis
@kindex o
@cindex magit-submodule-popup
@item @kbd{o} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.

@kindex o a
@cindex magit-submodule-add
@item @kbd{o a} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-add})

Add the repository at URL as a submodule.  Optional PATH is the path
to the submodule relative to the root of the super-project. If it is
nil then the path is determined based on URL.

@kindex o b
@cindex magit-submodule-setup
@item @kbd{o b} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-setup})

Clone and register missing submodules and checkout appropriate
commits.

@kindex o i
@cindex magit-submodule-init
@item @kbd{o i} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-init})

Register submodules listed in ".gitmodules" into ".git/config".

@kindex o u
@cindex magit-submodule-update
@item @kbd{o u} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-update})

Clone missing submodules and checkout appropriate commits.  With a
prefix argument also register submodules in ".git/config".

@kindex o s
@cindex magit-submodule-sync
@item @kbd{o s} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-sync})

Update each submodule's remote URL according to ".gitmodules".

@kindex o f
@cindex magit-submodule-fetch
@item @kbd{o f} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-fetch})

Fetch submodule.  With a prefix argument fetch all remotes.

@kindex o i
@cindex magit-submodule-init
@item @kbd{o i} @tie{}@tie{}@tie{}@tie{}(@code{magit-submodule-init})

Unregister the submodule at PATH.
@end table

@node Subtree
@section Subtree

Also see 
@ifinfo
@ref{git-subtree,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-subtree">git-subtree(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-subtree(1) manpage.
@end iftex

@table @asis
@kindex O
@cindex magit-tree-popup
@item @kbd{O} @tie{}@tie{}@tie{}@tie{}(@code{magit-tree-popup})

This prefix command shows the following suffix commands along with
the appropriate infix arguments in a popup buffer.
@end table

Most infix arguments only apply to some of the @code{git subtree}
subcommands.  When an argument that does not apply to the invoked
command is set, then it is silently ignored.

When the @code{--prefix} argument is set in the popup buffer, then that is
used.  Otherwise the prefix is read in the minibuffer.

@table @asis
@kindex O a
@cindex magit-subtree-add
@item @kbd{O a} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-add})

Add COMMIT from REPOSITORY as a new subtree at PREFIX.

@kindex O c
@cindex magit-subtree-add-commit
@item @kbd{O c} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-add-commit})

Add COMMIT as a new subtree at PREFIX.

@kindex O m
@cindex magit-subtree-merge
@item @kbd{O m} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-merge})

Merge COMMIT into the PREFIX subtree.

@kindex O f
@cindex magit-subtree-pull
@item @kbd{O f} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-pull})

Pull COMMIT from REPOSITORY into the PREFIX subtree.

@kindex O p
@cindex magit-subtree-push
@item @kbd{O p} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-push})

Extract the history of the subtree PREFIX and push it to REF on
REPOSITORY.

@kindex O s
@cindex magit-subtree-split
@item @kbd{O s} @tie{}@tie{}@tie{}@tie{}(@code{magit-subtree-split})

Extract the history of the subtree PREFIX.
@end table

@node Common Commands
@section Common Commands

These are some of the commands that can be used in all buffers whose
major-modes derive from @code{magit-mode}.  There are other common commands
beside the ones below, but these didn't fit well anywhere else.

@table @asis
@kindex M-w
@cindex magit-copy-section-value
@item @kbd{M-w} @tie{}@tie{}@tie{}@tie{}(@code{magit-copy-section-value})

This command saves the value of the current section to the
@code{kill-ring}, and, provided that the current section is a commit,
branch, or tag section, it also pushes the (referenced) revision to
the @code{magit-revision-stack}.

When the current section is a branch or a tag, and a prefix argument
is used, then it saves the revision at its tip to the @code{kill-ring}
instead of the reference name.

@kindex C-w
@cindex magit-copy-buffer-revision
@item @kbd{C-w} @tie{}@tie{}@tie{}@tie{}(@code{magit-copy-buffer-revision})

This command save the revision being displayed in the current buffer
to the @code{kill-ring} and also pushes it to the @code{magit-revision-stack}.  It
is mainly intended for use in @code{magit-revision-mode} buffers, the only
buffers where it is always unambiguous exactly which revision should
be saved.

Most other Magit buffers usually show more than one revision, in
some way or another, so this command has to select one of them, and
that choice might not always be the one you think would have been
the best pick.
@end table

Outside of Magit @code{M-w} and @code{C-w} are usually bound to @code{kill-ring-save} and
@code{kill-region}, and these commands would also be useful in Magit buffers.
Therefore when the region is active, then both of these commands
behave like @code{kill-ring-save} instead of as described above.

@node Wip Modes
@section Wip Modes

Git keeps @strong{committed} changes around long enough for users to recover
changes they have accidentally deleted.  It does so by not garbage
collecting any committed but no longer referenced objects for a
certain period of time, by default 30 days.

But Git does @strong{not} keep track of @strong{uncommitted} changes in the working tree
and not even the index (the staging area).  Because Magit makes it so
convenient to modify uncommitted changes, it also makes it easy to
shoot yourself in the foot in the process.

For that reason Magit provides three global modes that save @strong{tracked}
files to work-in-progress references after or before certain actions.
(Untracked files are never saved and these modes also only work after
the first commit has been created).

Two separate work-in-progress references are used to track the state
of the index and of the working tree: "refs/wip/index/<branchref>" and
"refs/wip/wtree/<branchref>", where @code{<branchref>} is the full ref of the
current branch, e.g. "refs/heads/master".  When the @code{HEAD} is detached
then "HEAD" is in place of @code{<branchref>}.

Checking out another branch (or detaching @code{HEAD}) causes the use of
different wip refs for subsequent changes, but the old refs are not
deleted.

Creating a commit and then making a change causes the wip refs to be
recreated to fork from the new commit.  But the old commits on the wip
refs are not lost.  They are still available from the reflog.  To make
it easier to see when the fork point of a wip ref was changed, an
additional commit with the message "restart autosaving" is created on
it (@code{xxO} commits below are such boundary commits).

Starting with

@example
      BI0---BI1    refs/wip/index/refs/heads/master
     /
A---B              refs/heads/master
     \
      BW0---BW1    refs/wip/wtree/refs/heads/master
@end example

and committing the staged changes and editing and saving a file would
result in

@example
      BI0---BI1        refs/wip/index/refs/heads/master
     /
A---B---C              refs/heads/master
     \   \
      \   CW0---CW1    refs/wip/wtree/refs/heads/master
       \
        BW0---BW1      refs/wip/wtree/refs/heads/master@@@{2@}
@end example

The fork-point of the index wip ref is not changed until some change
is being staged.  Likewise just checking out a branch or creating a
commit does not change the fork-point of the working tree wip ref.  The
fork-points are not adjusted until there actually is a change that
should be committed to the respective wip ref.

To view the log for the a branch and its wip refs use the commands
@code{magit-wip-log} and @code{magit-wip-log-current}.  You should use @code{--graph} when
using these commands.  Alternatively you can use the reflog to show
all commits that ever existed on a wip ref.  You can then recover lost
changes from the commits shown in the log or reflog.

@cindex magit-wip-log
@deffn Command magit-wip-log

This command shows the log for a branch and its wip refs.

With a negative prefix argument only the worktree wip ref is shown.
The absolute numeric value of the prefix argument controls how many
"branches" of each wip ref are shown.
@end deffn

@cindex magit-wip-log-current
@deffn Command magit-wip-log-current

This command shows the log for the current branch and its wip refs.

With a negative prefix argument only the worktree wip ref is shown.
The absolute numeric value of the prefix argument controls how many
"branches" of each wip ref are shown.
@end deffn

There exists a total of three global modes that save to the wip refs,
which might seem excessive, but allows fine tuning of when exactly
changes are being committed to the wip refs.  Enabling all modes makes
it less likely that a change slips through the cracks.

Setting the below variable directly does not take effect; either
customize them or call the respective mode function.

@defopt magit-wip-after-save-mode

When this mode is enabled, then saving a buffer that visits a file
tracked in a Git repository causes its current state to be committed
to the working tree wip ref for the current branch.
@end defopt

@defopt magit-wip-after-apply-mode

When this mode is enabled, then applying (i.e. staging, unstaging,
discarding, reversing, and regularly applying) a change to a file
tracked in a Git repository causes its current state to be committed
to the index and/or working tree wip refs for the current branch.
@end defopt

If you only ever edit files using Emacs and only ever interact with
Git using Magit, then the above two modes should be enough to protect
each and every change from accidental loss.  In practice nobody does
that.  So an additional mode exists that does commit to the wip refs
before making changes that could cause the loss of earlier changes.

@defopt magit-wip-before-change-mode

When this mode is enabled, then certain commands commit the existing
changes to the files they are about to make changes to.
@end defopt

Note that even if you enable all three modes this won't give you
perfect protection.  The most likely scenario for losing changes
despite the use of these modes is making a change outside Emacs and
then destroying it also outside Emacs.  In such a scenario, Magit,
being an Emacs package, didn't get the opportunity to keep you from
shooting yourself in the foot.

When you are unsure whether Magit did commit a change to the wip refs,
then you can explicitly request that all changes to all tracked files
are being committed.

@table @asis
@kindex M-x magit-wip-commit
@cindex magit-wip-commit
@item @kbd{M-x magit-wip-commit} @tie{}@tie{}@tie{}@tie{}(@code{magit-wip-commit})

This command commits all changes to all tracked files to the index
and working tree work-in-progress refs.  Like the modes described above,
it does not commit untracked files, but it does check all tracked
files for changes.  Use this command when you suspect that the modes
might have overlooked a change made outside Emacs/Magit.

@end table

@defopt magit-wip-after-save-local-mode-lighter

Mode-line lighter for @code{magit-wip-after-save-local-mode}.
@end defopt

@defopt magit-wip-after-apply-mode-lighter

Mode-line lighter for @code{magit-wip-after-apply-mode}.
@end defopt

@defopt magit-wip-before-change-mode-lighter

Mode-line lighter for @code{magit-wip-before-change-mode}.
@end defopt

@defopt magit-wip-namespace

The namespace used for work-in-progress refs.  It has to end with a
slash.  The wip refs are named "<namespace>index/<branchref>" and
"<namespace>wtree/<branchref>".  When snapshots are created while
the @code{HEAD} is detached then "HEAD" is used in place of @code{<branchref>}.
@end defopt

@node Minor Mode for Buffers Visiting Files
@section Minor Mode for Buffers Visiting Files

The @code{magit-file-mode} enables certain Magit features in file-visiting
buffers belonging to a Git repository.  It should be enabled globally
using @code{global-magit-file-mode}.  Currently this mode only establishes a
few key bindings, but this might be extended in the future.

@defopt magit-file-mode

Whether to establish certain Magit key bindings in all file-visiting
buffers belonging to a Git repository.  This establishes the
bindings suggested in @ref{Getting Started} (but only for file-visiting
buffers), and additionally binds @code{C-c M-g} to @code{magit-file-popup}.
@end defopt

@table @asis
@kindex C-c M-g
@cindex magit-file-popup
@item @kbd{C-c M-g} @tie{}@tie{}@tie{}@tie{}(@code{magit-file-popup})

This prefix command shows a popup buffer featuring suffix commands
that operate on the file being visited in the current buffer.

@kindex C-c M-g s
@cindex magit-stage-file
@item @kbd{C-c M-g s} @tie{}@tie{}@tie{}@tie{}(@code{magit-stage-file})

Stage all changes to the file being visited in the current buffer.

@kindex C-c M-g u
@cindex magit-unstage-file
@item @kbd{C-c M-g u} @tie{}@tie{}@tie{}@tie{}(@code{magit-unstage-file})

Unstage all changes to the file being visited in the current buffer.

@kindex C-c M-g c
@cindex magit-commit-popup
@item @kbd{C-c M-g c} @tie{}@tie{}@tie{}@tie{}(@code{magit-commit-popup})

This prefix command shows suffix commands along with the appropriate
infix arguments in a popup buffer.  See @ref{Initiating a Commit}.

@kindex C-c M-g D
@cindex magit-diff-buffer-file-popup
@item @kbd{C-c M-g D} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-buffer-file-popup})

This prefix command shows the same suffix commands and infix
arguments in a popup buffer as @code{magit-diff-popup}.  But this variant
has to be called from a file-visiting buffer and the visited file
is automatically used in the popup to limit the diff to that file.

@kindex C-c M-g d
@cindex magit-diff-buffer-file
@item @kbd{C-c M-g d} @tie{}@tie{}@tie{}@tie{}(@code{magit-diff-buffer-file})

This command shows the diff for the file of blob that the current
buffer visits.

@end table

@defopt magit-diff-buffer-file-locked

This option controls whether @code{magit-diff-buffer-file} uses a decicated
buffer.  See @ref{Modes and Buffers}.
@end defopt

@table @asis
@kindex C-c M-g L
@cindex magit-log-buffer-file-popup
@item @kbd{C-c M-g L} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-buffer-file-popup})

This prefix command shows the same suffix commands and infix
arguments in a popup buffer as @code{magit-log-popup}.  But this variant
has to be called from a file-visiting buffer and the visited file
is automatically used in the popup to limit the log to that file.

@kindex C-c M-g l
@cindex magit-log-buffer-file
@item @kbd{C-c M-g l} @tie{}@tie{}@tie{}@tie{}(@code{magit-log-buffer-file})

This command shows the log for the file of blob that the current
buffer visits.  Renames are followed when a prefix argument is used
or when @code{--follow} is part of @code{magit-log-arguments}.  When the
region is active, the log is restricted to the selected line range.

@end table

@defopt magit-log-buffer-file-locked

This option controls whether @code{magit-log-buffer-file} uses a decicated
buffer.  See @ref{Modes and Buffers}.
@end defopt

@table @asis
@kindex C-c M-g b
@cindex magit-blame-popup
@item @kbd{C-c M-g b} @tie{}@tie{}@tie{}@tie{}(@code{magit-blame-popup})

This prefix command shows the @code{magit-blame} suffix command along with
the appropriate infix arguments in a popup buffer.  See @ref{Initiating a Commit}.

@kindex C-c M-g p
@cindex magit-blob-previous
@item @kbd{C-c M-g p} @tie{}@tie{}@tie{}@tie{}(@code{magit-blob-previous})

Visit the previous blob which modified the current file.
@end table

@node Minor Mode for Buffers Visiting Blobs
@section Minor Mode for Buffers Visiting Blobs

The @code{magit-blob-mode} enables certain Magit features in blob-visiting
buffers.  Such buffers can be created using @code{magit-find-file} and some
of the commands mentioned below, which also take care of turning on
this minor mode.  Currently this mode only establishes a few key
bindings, but this might be extended.

@table @asis
@kindex p
@cindex magit-blob-previous
@item @kbd{p} @tie{}@tie{}@tie{}@tie{}(@code{magit-blob-previous})

Visit the previous blob which modified the current file.

@kindex n
@cindex magit-blob-next
@item @kbd{n} @tie{}@tie{}@tie{}@tie{}(@code{magit-blob-next})

Visit the next blob which modified the current file.

@kindex q
@cindex magit-kill-this-buffer
@item @kbd{q} @tie{}@tie{}@tie{}@tie{}(@code{magit-kill-this-buffer})

Kill the current buffer.
@end table

@node Customizing
@chapter Customizing

Both Git and Emacs are highly customizable.  Magit is both a Git
porcelain as well as an Emacs package, so it makes sense to customize
it using both Git variables as well as Emacs options.  However this
flexibility doesn't come without problems, including but not limited
to the following.

@itemize
@item
Some Git variables automatically have an effect in Magit without
requiring any explicit support.  Sometimes that is desirable - in
other cases, it breaks Magit.

When a certain Git setting breaks Magit but you want to keep using
that setting on the command line, then that can be accomplished by
overriding the value for Magit only by appending something like
@code{("-c" "some.variable=compatible-value")} to
@code{magit-git-global-arguments}.


@item
Certain settings like @code{fetch.prune=true} are respected by Magit
commands (because they simply call the respective Git command) but
their value is not reflected in the respective popup buffers.  In
this case the @code{--prune} argument in @code{magit-fetch-popup} might be active
or inactive depending on the value of @code{magit-fetch-arguments} only,
but that doesn't keep the Git variable from being honored by the
suffix commands anyway.  So pruning might happen despite the the
@code{--prune} arguments being displayed in a way that seems to indicate
that no pruning will happen.
@end itemize

I intend to address these and similar issues in a future release.

@menu
* Per-Repository Configuration::
* Essential Settings::
@end menu

@node Per-Repository Configuration
@section Per-Repository Configuration

Magit can be configured on a per-repository level using both Git
variables as well as Emacs options.

To set a Git variable for one repository only, simply set it in
@code{/path/to/repo/.git/config} instead of @code{$HOME/.gitconfig} or
@code{/etc/gitconfig}.  See 
@ifinfo
@ref{git-config,,,gitman,}.
@end ifinfo
@ifhtml
@html
the <a href="http://git-scm.com/docs/git-config">git-config(1)</a> manpage.
@end html
@end ifhtml
@iftex
the git-config(1) manpage.
@end iftex

Similarly, Emacs options can be set for one repository only by editing
@code{/path/to/repo/.dir-locals.el}.  See @ref{Directory Variables,,,emacs,}.
For example to disable automatic refreshes of file-visiting buffers in
just one huge repository use this:

@itemize
@item
@code{/path/to/huge/repo/.dir-locals.el}

@lisp
((nil . ((magit-refresh-buffers . nil))
@end lisp
@end itemize

If you want to apply the same settings to several, but not all,
repositories then keeping the repository-local config files in sync
would quickly become annoying.  To avoid that you can create config
files for certain classes of repositories (e.g. "huge repositories")
and then include those files in the per-repository config files.
For example:

@itemize
@item
@code{/path/to/huge/repo/.git/config}

@example
[include]
        path = /path/to/huge-gitconfig
@end example


@item
@code{/path/to/huge-gitconfig}

@example
[status]
        showUntrackedFiles = no
@end example


@item
@code{$HOME/.emacs.d/init.el}

@lisp
(dir-locals-set-class-variables 'huge-git-repository
   '((nil . ((magit-refresh-buffers . nil)))))

(dir-locals-set-directory-class
   "/path/to/huge/repo/" 'huge-git-repository)
@end lisp
@end itemize

@node Essential Settings
@section Essential Settings

The next two sections list and discuss several variables that many
users might want to customize, for safety and/or performance reasons.

@menu
* Safety::
* Performance::
@end menu

@node Safety
@subsection Safety

This section discusses various variables that you might want to
change (or @strong{not} change) for safety reasons.

Git keeps @strong{committed} changes around long enough for users to recover
changes they have accidentally been deleted.  It does not do the same
for @strong{uncommitted} changes in the working tree and not even the index
(the staging area).  Because Magit makes it so easy to modify
uncommitted changes, it also makes it easy to shoot yourself in the
foot in the process.  For that reason Magit provides three global
modes that save @strong{tracked} files to work-in-progress references after or
before certain actions.  See @ref{Wip Modes}.

These modes are not enabled by default because of performance
concerns.  Instead a lot of potentially destructive commands require
confirmation every time they are used.  In many cases this can be
disabled by adding a symbol to @code{magit-no-confirm} (see @ref{Completion and Confirmation}).  If you enable the various wip modes then you should
add @code{safe-with-wip} to this list.

Similarly it isn't necessary to require confirmation before moving a
file to the system trash - if you trashed a file by mistake then you
can recover it from the there.  Option @code{magit-delete-by-moving-to-trash}
controls whether the system trash is used, which is the case by default.
Nevertheless, @code{trash} isn't a member of @code{magit-no-confirm} - you
might want to change that.

By default buffers visiting files are automatically reverted when the
visited file changes on disk.  This isn't as risky as it might seem,
but to make an informed decision you should see @ref{Risk of Reverting Automatically}.

@node Performance
@subsection Performance

After Magit has run @code{git} for side-effects, it also refreshes the
current Magit buffer and the respective status buffer.  This is
necessary because otherwise outdated information might be displayed
without the user noticing.  Magit buffers are updated by recreating
their content from scratch, which makes updating simpler and less
error-prone, but also more costly.  Keeping it simple and just
re-creating everything from scratch is an old design decision and
departing from that will require major refactoring.

I plan to do that in time for the next major release.  I also intend
to create logs and diffs asynchronously, which should also help a lot
but also requires major refactoring.

Meanwhile you can tell Magit to only automatically refresh the current
Magit buffer, but not the status buffer.  If you do that, then the
status buffer is only refreshed automatically if it itself is the
current buffer.

@lisp
(setq magit-refresh-status-buffer nil)
@end lisp

You should also check whether any third-party packages have added
anything to @code{magit-refresh-buffer-hook}, @code{magit-status-refresh-hook},
@code{magit-pre-refresh-hook}, and @code{magit-post-refresh-hook}.  If so, then
check whether those additions impacts performance significantly.
Setting @code{magit-refresh-verbose} and then inspecting the output in the
@code{*Messages*} buffer, should help doing so.

Magit also reverts buffers which visit files located inside the
current repository, when the visited file changes on disk.  That is
implemented on top of @code{auto-revert-mode} from the built-in library
@code{autorevert}.  To figure out whether that impacts performance, check
whether performance is significantly worse, when many buffers exist
and/or when some buffers visit files using Tramp.  If so, then this
should help.

@lisp
(setq auto-revert-buffer-list-filter
      'magit-auto-revert-repository-buffers-p)
@end lisp

For alternative approaches see @ref{Automatic Reverting of File-Visiting Buffers}.

If you have enabled any features that are disabled by default, then
you should check whether they impact performance significantly.  It's
likely that they were not enabled by default because it is known that
they reduce performance at least in large repositories.

If performance is only slow inside certain unusually large
repositories, then you might want to disable certain features on a
per-repository or per-repository-class basis only.  See
@ref{Per-Repository Configuration}.

@menu
* Microsoft Windows Performance::
* MacOS Performance::
@end menu

@unnumberedsubsubsec Log Performance

When showing logs, Magit limits the number of commits initially shown
in the hope that this avoids unnecessary work.  When using @code{--graph} is
used, then this unfortunately does not have the desired effect for
large histories.  Junio, Git's maintainer, said on the git mailing
list (@uref{http://www.spinics.net/lists/git/msg232230.html}): "@code{--graph} wants
to compute the whole history and the max-count only affects the output
phase after @code{--graph} does its computation".

In other words, it's not that Git is slow at outputting the
differences, or that Magit is slow at parsing the output - the problem
is that Git first goes outside and has a smoke.

We actually work around this issue by limiting the number of commits
not only by using @code{-<N>} but by also using a range.  But unfortunately
that's not always possible.

In repositories with more than a few thousand commits @code{--graph} should
never be a member of @code{magit-log-section-arguments}.  That variable is
used in the status buffer which is refreshed every time you run any
Magit command.

Using @code{--color --graph} is even slower.  Magit uses code that is part of
Emacs to turn control characters into faces.  That code is pretty slow
and this is quite noticeable when showing a log with many branches and
merges.  For that reason @code{--color} is not enabled by default anymore.
Consider leaving it at that.

@unnumberedsubsubsec Diff Performance

If diffs are slow, then consider turning off some optional diff
features by setting all or some of the following variables to @code{nil}:
@code{magit-diff-highlight-indentation}, @code{magit-diff-highlight-trailing},
@code{magit-diff-paint-whitespace}, @code{magit-diff-highlight-hunk-body}, and
@code{magit-diff-refine-hunk}.

When showing a commit instead of some arbitrary diff, then some
additional information is displayed.  Calculating this information
can be quite expensive given certain circumstances.  If looking at
a commit using @code{magit-revision-mode} takes considerably more time than
looking at the same commit in @code{magit-diff-mode}, then consider setting
@code{magit-revision-insert-related-refs} to @code{nil}.

@unnumberedsubsubsec Refs Buffer Performance

When refreshing the "references buffer" is slow, then that's usually
because several hundred refs are being displayed.  The best way to
address that is to display fewer refs, obviously.

If you are not, or only mildly, interested in seeing the list of tags,
then start by not displaying them:

@lisp
(remove-hook 'magit-refs-sections-hook 'magit-insert-tags)
@end lisp

Then you should also make sure that the listed remote branches
actually all exist.  You can do so by pruning branches which no longer
exist using @code{f-pa}.

@unnumberedsubsubsec Committing Performance

When you initiate a commit, then Magit by default automatically shows
a diff of the changes you are about to commit.  For large commits this
can take a long time, which is especially distracting when you are
committing large amounts of generated data which you don't actually
intend to inspect before committing.  This behavior can be turned off
using:

@lisp
(remove-hook 'server-switch-hook 'magit-commit-diff)
@end lisp

Then you can type @code{C-c C-d} to show the diff when you actually want to
see it, but only then.  Alternatively you can leave the hook alone and
just type @code{C-g} in those cases when it takes to long to generate the
diff.  If you do that, then you will end up with a broken diff buffer,
but doing it this way has the advantage that you usually get to see
the diff, which is useful because it increases the odds that you spot
potential issues.

@unnumberedsubsubsec The Built-In VC Package

Emacs comes with a version control interface called "VC", see
@ref{Version Control,,,emacs,}.  It is enabled be default and if you don't
use it in addition to Magit, then you should disable it to keep it
from performing unnecessary work:

@lisp
(setq vc-handled-backends nil)
@end lisp

You can also disable its use only for Git but keep using it when using
another version control system:

@lisp
(setq vc-handled-backends (delq 'Git vc-handled-backends))
@end lisp

@node Microsoft Windows Performance
@unnumberedsubsubsec Microsoft Windows Performance

In order to update the status buffer, @code{git} has to be run a few dozen
times.  That is problematic on Microsoft Windows, because that
operating system is exceptionally slow at starting processes.  Sadly
this is an issue that can only be fixed by Microsoft itself, and they
don't appear to be particularly interested in doing so.

Beside the subprocess issue, there also exist other Window-specific
performance issues, some of which can be worked around.  The
maintainers of "Git for Windows" try to reduce their effect, and in
order to benefit from the latest performance tweaks, should always
use the latest release.  Magit too tries to work around some
Windows-specific issues.

According to some sources setting the following Git variables can also
help.

@example
git config --global core.preloadindex true   # default since v2.1
git config --global core.fscache true        # default since v2.8
git config --global gc.auto 256
@end example

You should also check whether an anti-virus program is slowing things
down.

@node MacOS Performance
@unnumberedsubsubsec MacOS Performance

On macOS Emacs currently creates child processes using @code{fork}.  It
appears that this also copies GUI resources.  The result is that
forking takes about 30 times as long on Darwin than on Linux.  And
because Magit starts many @code{git} processes even when doing simple things,
that makes quite a difference.

On the @code{master} branch Emacs now uses @code{vfork} when possible, like this was
already done on Linux, and now child creation only takes about twice
as long on Darwin.  See @footnote{@uref{https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html}} for more information.

Nobody knows when the changes on the @code{master} branch will be released as
@code{26.1}, but it is still a long way off.  You might want to get your
hands on this change before then.  The easiest way to get a patched
Emacs is to install the @code{emacs-plus} formula @footnote{@uref{https://github.com/d12frosted/homebrew-emacs-plus}} using @code{homebrew}.
The change has been backported, so you get it not only when using
@code{--HEAD}, but also when using @code{--devel} or when installing the latest
release (by not using a version argument).

Alternatively you can apply the backport @footnote{@uref{https://gist.githubusercontent.com/aaronjensen/f45894ddf431ecbff78b1bcf533d3e6b/raw/6a5cd7f57341aba673234348d8b0d2e776f86719/Emacs-25-OS-X-use-vfork.patch}} manually.

@node Plumbing
@chapter Plumbing

The following sections describe how to use several of Magit's core
abstractions to extend Magit itself or implement a separate extension.

A few of the low-level features used by Magit have been factored out
into separate libraries/packages, so that they can be used by other
packages, without having to depend on Magit.  These libraries are
described in separate manuals, see @ref{Top,,,with-editor,} and
@ref{Top,,,magit-popup,}.

If you are trying to find an unused key that you can bound to a
command provided by your own Magit extension, then checkout
@uref{https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry}.

@menu
* Calling Git::
* Section Plumbing::
* Refreshing Buffers::
* Conventions::
@end menu

@node Calling Git
@section Calling Git

Magit provides many specialized functions for calling Git.  All of
these functions are defined in either @code{magit-git.el} or @code{magit-process.el}
and have one of the prefixes @code{magit-run-}, @code{magit-call-}, @code{magit-start-},
or @code{magit-git-} (which is also used for other things).

All of these functions accept an indefinite number of arguments, which
are strings that specify command line arguments for git (or in some
cases an arbitrary executable).  These arguments are flattened before
being passed on to the executable; so instead of strings they can also
be lists of strings and arguments that are @code{nil} are silently dropped.
Some of these functions also require a single mandatory argument
before these command line arguments.

Roughly speaking these functions run Git either to get some value or
for side-effect.  The functions that return a value are useful to
collect the information necessary to populate a Magit buffer, while
the others are used to implement Magit commands.

The functions in the value-only group always run synchronously, and
they never trigger a refresh.  The function in the side-effect group
can be further divided into subgroups depending on whether they run
Git synchronously or asynchronously, and depending on whether they
trigger a refresh when the executable has finished.

@menu
* Getting a Value from Git::
* Calling Git for Effect::
@end menu

@node Getting a Value from Git
@subsection Getting a Value from Git

These functions run Git in order to get a value, either its exit
status or its output.  Of course you could also use them to run Git
commands that have side-effects, but that should be avoided.

@defun magit-git-exit-code &rest args

Executes git with ARGS and returns its exit code.
@end defun

@defun magit-git-success &rest args

Executes git with ARGS and returns @code{t} if the exit code is @code{0}, @code{nil}
otherwise.
@end defun

@defun magit-git-failure &rest args

Executes git with ARGS and returns @code{t} if the exit code is @code{1}, @code{nil}
otherwise.
@end defun

@defun magit-git-true &rest args

Executes git with ARGS and returns @code{t} if the first line printed by
git is the string "true", @code{nil} otherwise.
@end defun

@defun magit-git-false &rest args

Executes git with ARGS and returns @code{t} if the first line printed by
git is the string "false", @code{nil} otherwise.
@end defun

@defun magit-git-insert &rest args

Executes git with ARGS and inserts its output at point.
@end defun

@defun magit-git-string &rest args

Executes git with ARGS and returns the first line of its output.  If
there is no output or if it begins with a newline character, then
this returns @code{nil}.
@end defun

@defun magit-git-lines &rest args

Executes git with ARGS and returns its output as a list of lines.
Empty lines anywhere in the output are omitted.
@end defun

@defun magit-git-items &rest args

Executes git with ARGS and returns its null-separated output as a
list.  Empty items anywhere in the output are omitted.

If the value of option @code{magit-git-debug} is non-nil and git exits with
a non-zero exit status, then warn about that in the echo area and
add a section containing git's standard error in the current
repository's process buffer.
@end defun

When an error occurs when using one of the above functions, then that
is usually due to a bug, i.e. the use of an argument which is not
actually supported.  Such errors are usually not reported, but when
they occur we need to be able to debug them.

@defopt magit-git-debug

Whether to report errors that occur when using @code{magit-git-insert},
@code{magit-git-string}, @code{magit-git-lines}, or @code{magit-git-items}.  This does
not actually raise an error.  Instead a message is shown in the echo
area, and git's standard error is insert into a new section in the
current repository's process buffer.
@end defopt

@defun magit-git-str &rest args

This is a variant of @code{magit-git-string} that ignores the option
@code{magit-git-debug}.  It is mainly intended to be used while handling
errors in functions that do respect that option.  Using such a
function while handing an error could cause yet another error and
therefore lead to an infinite recursion.  You probably won't ever
need to use this function.
@end defun

@node Calling Git for Effect
@subsection Calling Git for Effect

These functions are used to run git to produce some effect.  Most
Magit commands that actually run git do so by using such a function.

Because we do not need to consume git's output when using these
functions, their output is instead logged into a per-repository
buffer, which can be shown using @code{$} from a Magit buffer or @code{M-x
magit-process} elsewhere.

These functions can have an effect in two distinct ways.  Firstly,
running git may change something, i.e. create or push a new commit.
Secondly, that change may require that Magit buffers are refreshed to
reflect the changed state of the repository.  But refreshing isn't
always desirable, so only some of these functions do perform such a
refresh after git has returned.

Sometimes it is useful to run git asynchronously.  For example, when
the user has just initiated a push, then there is no reason to make
her wait until that has completed.  In other cases it makes sense to
wait for git to complete before letting the user do something else.
For example after staging a change it is useful to wait until after
the refresh because that also automatically moves to the next change.

@defun magit-call-git &rest args

Calls git synchronously with ARGS.
@end defun

@defun magit-call-process program &rest args

Calls PROGRAM synchronously with ARGS.
@end defun

@defun magit-run-git &rest args

Calls git synchronously with ARGS and then refreshes.
@end defun

@defun magit-run-git-with-input input &rest args

Calls git synchronously with ARGS and sends it INPUT on standard
input.

INPUT should be a buffer or the name of an existing buffer.  The
content of that buffer is used as the process' standard input.
After the process returns a refresh is performed.

As a special case, INPUT may also be nil.  In that case the content
of the current buffer is used as standard input and @strong{no} refresh is
performed.

This function actually runs git asynchronously.  But then it waits
for the process to return, so the function itself is synchronous.
@end defun

@defun magit-run-git-with-logfile file &rest args

Calls git synchronously with ARGS.  The process' output is saved in
FILE.  This is rarely useful and so this function might be removed
in the future.

This function actually runs git asynchronously.  But then it waits
for the process to return, so the function itself is synchronous.
@end defun

@defun magit-git &rest args

Calls git synchronously with ARGS for side-effects only.  This
function does not refresh the buffer.
@end defun

@defun magit-git-wash washer &rest args

Execute Git with ARGS, inserting washed output at point.  Actually
first insert the raw output at point.  If there is no output call
@code{magit-cancel-section}.  Otherwise temporarily narrow the buffer to
the inserted text, move to its beginning, and then call function
WASHER with ARGS as its sole argument.
@end defun

And now for the asynchronous variants.

@defun magit-run-git-async &rest args

Start Git, prepare for refresh, and return the process object.
ARGS is flattened and then used as arguments to Git.

Display the command line arguments in the echo area.

After Git returns some buffers are refreshed: the buffer that was
current when this function was called (if it is a Magit buffer and
still alive), as well as the respective Magit status buffer.
Unmodified buffers visiting files that are tracked in the current
repository are reverted if @code{magit-revert-buffers} is non-nil.
@end defun

@defun magit-run-git-with-editor &rest args

Export GIT@math{_EDITOR} and start Git.  Also prepare for refresh and
return the process object.  ARGS is flattened and then used as
arguments to Git.

Display the command line arguments in the echo area.

After Git returns some buffers are refreshed: the buffer that was
current when this function was called (if it is a Magit buffer and
still alive), as well as the respective Magit status buffer.
@end defun

@defun magit-start-git &rest args

Start Git, prepare for refresh, and return the process object.

If INPUT is non-nil, it has to be a buffer or the name of an
existing buffer.  The buffer content becomes the processes
standard input.

Option @code{magit-git-executable} specifies the Git executable and option
@code{magit-git-global-arguments} specifies constant arguments.  The
remaining arguments ARGS specify arguments to Git.  They are
flattened before use.

After Git returns, some buffers are refreshed: the buffer that was
current when this function was called (if it is a Magit buffer and
still alive), as well as the respective Magit status buffer.
Unmodified buffers visiting files that are tracked in the current
repository are reverted if @code{magit-revert-buffers} is non-nil.
@end defun

@defun magit-start-process &rest args

Start PROGRAM, prepare for refresh, and return the process object.

If optional argument INPUT is non-nil, it has to be a buffer or
the name of an existing buffer.  The buffer content becomes the
processes standard input.

The process is started using @code{start-file-process} and then setup to
use the sentinel @code{magit-process-sentinel} and the filter
@code{magit-process-filter}.  Information required by these functions is
stored in the process object.  When this function returns the
process has not started to run yet so it is possible to override the
sentinel and filter.

After the process returns, @code{magit-process-sentinel} refreshes the
buffer that was current when @code{magit-start-process} was called (if it
is a Magit buffer and still alive), as well as the respective Magit
status buffer.  Unmodified buffers visiting files that are tracked
in the current repository are reverted if @code{magit-revert-buffers} is
non-nil.
@end defun

@defvar magit-this-process

The child process which is about to start.  This can be used to
change the filter and sentinel.
@end defvar

@defvar magit-process-raise-error

When this is non-nil, then @code{magit-process-sentinel} raises an error if
git exits with a non-zero exit status.  For debugging purposes.
@end defvar

@node Section Plumbing
@section Section Plumbing

@menu
* Creating Sections::
* Section Selection::
* Matching Sections::
@end menu

@node Creating Sections
@subsection Creating Sections

@defmac magit-insert-section &rest args

Insert a section at point.

TYPE is the section type, a symbol.  Many commands that act on the
current section behave differently depending on that type.  Also if
a variable @code{magit-TYPE-section-map} exists, then use that as the
text-property @code{keymap} of all text belonging to the section (but this
may be overwritten in subsections).  TYPE can also have the form
@code{(eval FORM)} in which case FORM is evaluated at runtime.

Optional VALUE is the value of the section, usually a string that is
required when acting on the section.

When optional HIDE is non-nil collapse the section body by default,
i.e. when first creating the section, but not when refreshing the
buffer.  Otherwise, expand it by default.  This can be overwritten using
@code{magit-section-set-visibility-hook}.  When a section is recreated
during a refresh, then the visibility of predecessor is inherited
and HIDE is ignored (but the hook is still honored).

BODY is any number of forms that actually insert the section's
heading and body.  Optional NAME, if specified, has to be a symbol,
which is then bound to the struct of the section being inserted.

Before BODY is evaluated the @code{start} of the section object is set to
the value of @code{point} and after BODY was evaluated its @code{end} is set to
the new value of @code{point}; BODY is responsible for moving @code{point}
forward.

If it turns out inside BODY that the section is empty, then
@code{magit-cancel-section} can be used to abort and remove all traces of
the partially inserted section.  This can happen when creating a
section by washing Git's output and Git didn't actually output
anything this time around.
@end defmac

@defun magit-insert-heading &rest args

Insert the heading for the section currently being inserted.

This function should only be used inside @code{magit-insert-section}.

When called without any arguments, then just set the @code{content} slot of
the object representing the section being inserted to a marker at
@code{point}.  The section should only contain a single line when this
function is used like this.

When called with arguments ARGS, which have to be strings, then
insert those strings at point.  The section should not contain any
text before this happens and afterwards it should again only contain
a single line.  If the @code{face} property is set anywhere inside any of
these strings, then insert all of them unchanged.  Otherwise use the
@code{magit-section-heading} face for all inserted text.

The @code{content} property of the section struct is the end of the heading
(which lasts from @code{start} to @code{content}) and the beginning of the body
(which lasts from @code{content} to @code{end}).  If the value of @code{content} is nil,
then the section has no heading and its body cannot be collapsed.
If a section does have a heading then its height must be exactly one
line, including a trailing newline character.  This isn't enforced;
you are responsible for getting it right.  The only exception is
that this function does insert a newline character if necessary.
@end defun

@defun magit-cancel-section

Cancel the section currently being inserted.  This exits the
innermost call to @code{magit-insert-section} and removes all traces of
what has already happened inside that call.
@end defun

@defun magit-define-section-jumper sym title &optional value

Define an interactive function to go to section SYM.  TITLE is the
displayed title of the section.
@end defun

@node Section Selection
@subsection Section Selection

@defun magit-current-section

Return the section at point.
@end defun

@defun magit-region-sections

Return a list of the selected sections.

When the region is active and constitutes a valid section selection,
then return a list of all selected sections.  This is the case when
the region begins in the heading of a section and ends in the
heading of a sibling of that first section.  When the selection is
not valid then return nil.  Most commands that can act on the
selected sections, then instead just act on the current section, the
one point is in.

When the region looks like it would in any other buffer then the
selection is invalid.  When the selection is valid then the region
uses the @code{magit-section-highlight}.  This does not apply to diffs where
things get a bit more complicated, but even here if the region looks
like it usually does, then that's not a valid selection as far as
this function is concerned.
@end defun

@defun magit-region-values &rest types

Return a list of the values of the selected sections.

Also see @code{magit-region-sections} whose doc-string explains when a
region is a valid section selection.  If the region is not active
or is not a valid section selection, then return nil.  If optional
TYPES is non-nil then the selection not only has to be valid; the
types of all selected sections additionally have to match one of
TYPES, or nil is returned.
@end defun

@node Matching Sections
@subsection Matching Sections

@table @asis
@kindex M-x magit-describe-section
@cindex magit-describe-section
@item @kbd{M-x magit-describe-section} @tie{}@tie{}@tie{}@tie{}(@code{magit-describe-section})

Show information about the section at point.  This command is
intended for debugging purposes.

@end table

@defun magit-section-ident

Return an unique identifier for SECTION.  The return value has the
form @code{((TYPE . VALUE)...)}.
@end defun

@defun magit-get-section

Return the section identified by IDENT.  IDENT has to be a list as
returned by @code{magit-section-ident}.
@end defun

@defun magit-section-match condition &optional section

Return @code{t} if SECTION matches CONDITION.  SECTION defaults to the
section at point.  If SECTION is not specified and there also is no
section at point, then return @code{nil}.

CONDITION can take the following forms:
@itemize
@item
@code{(CONDITION...)}

matches if any of the CONDITIONs matches.


@item
@code{[TYPE...]}

matches if the first TYPE matches the type of the section, the
second matches that of its parent, and so on.


@item
@code{[* TYPE...]}

matches sections that match [TYPE@dots{}] and also recursively all
their child sections.


@item
@code{TYPE}

matches sections of TYPE regardless of the types of the parent
sections.
@end itemize
Each TYPE is a symbol.  Note that it is not necessary to specify all
TYPEs up to the root section as printed by @code{magit-describe-type},
unless of course you want to be that precise.
@end defun

@defun magit-section-when condition &rest body

If the section at point matches CONDITION evaluate BODY.

If the section matches, then evaluate BODY forms sequentially with
@code{it} bound to the section and return the value of the last form.  If
there are no BODY forms, then return the value of the section.  If
the section does not match or if there is no section at point then
return nil.

See @code{magit-section-match} for the forms CONDITION can take.
@end defun

@defun magit-section-case &rest clauses

Choose among clauses on the type of the section at point.

Each clause looks like (CONDITION BODY@dots{}).  The type of the
section is compared against each CONDITION; the BODY forms of the
first match are evaluated sequentially and the value of the last
form is returned.  Inside BODY the symbol @code{it} is bound to the
section at point.  If no clause succeeds or if there is no
section at point return nil.

See @code{magit-section-match} for the forms CONDITION can take.
Additionally a CONDITION of t is allowed in the final clause and
matches if no other CONDITION match, even if there is no section at
point.
@end defun

@defvar magit-root-section

The root section in the current buffer.  All other sections are
descendants of this section.  The value of this variable is set by
@code{magit-insert-section} and you should never modify it.
@end defvar

For diff related sections a few additional tools exist.

@defun magit-diff-type &optional section

Return the diff type of SECTION.

The returned type is one of the symbols @code{staged}, @code{unstaged}, @code{committed},
or @code{undefined}.  This type serves a similar purpose as the general
type common to all sections (which is stored in the @code{type} slot of the
corresponding @code{magit-section} struct) but takes additional information
into account.  When the SECTION isn't related to diffs and the
buffer containing it also isn't a diff-only buffer, then return nil.

Currently the type can also be one of @code{tracked} and @code{untracked}, but
these values are not handled explicitly in every place they should
be.  A possible fix could be to just return nil here.

The section has to be a @code{diff} or @code{hunk} section, or a section whose
children are of type @code{diff}.  If optional SECTION is nil, return the
diff type for the current section.  In buffers whose major mode is
@code{magit-diff-mode} SECTION is ignored and the type is determined using
other means.  In @code{magit-revision-mode} buffers the type is always
@code{committed}.
@end defun

@defun magit-diff-scope &optional section strict

Return the diff scope of SECTION or the selected section(s).

A diff's "scope" describes what part of a diff is selected, it is a
symbol, one of @code{region}, @code{hunk}, @code{hunks}, @code{file}, @code{files}, or @code{list}.  Do not
confuse this with the diff "type", as returned by @code{magit-diff-type}.

If optional SECTION is non-nil, then return the scope of that,
ignoring the sections selected by the region.  Otherwise return the
scope of the current section, or if the region is active and selects
a valid group of diff related sections, the type of these sections,
i.e. @code{hunks} or @code{files}.  If SECTION (or if the current section that
is nil) is a @code{hunk} section and the region starts and ends inside
the body of a that section, then the type is @code{region}.

If optional STRICT is non-nil then return nil if the diff type of
the section at point is @code{untracked} or the section at point is not
actually a @code{diff} but a @code{diffstat} section.
@end defun

@node Refreshing Buffers
@section Refreshing Buffers

All commands that create a new Magit buffer or change what is being
displayed in an existing buffer do so by calling @code{magit-mode-setup}.
Among other things, that function sets the buffer local values of
@code{default-directory} (to the top-level of the repository),
@code{magit-refresh-function}, and @code{magit-refresh-args}.

Buffers are refreshed by calling the function that is the local value
of @code{magit-refresh-function} (a function named @code{magit-*-refresh-buffer},
where @code{*} may be something like @code{diff}) with the value of
@code{magit-refresh-args} as arguments.

@defmac magit-mode-setup buffer switch-func mode refresh-func &optional refresh-args

This function displays and selects BUFFER, turns on MODE, and
refreshes a first time.

This function displays and optionally selects BUFFER by calling
@code{magit-mode-display-buffer} with BUFFER, MODE and SWITCH-FUNC as
arguments.  Then it sets the local value of @code{magit-refresh-function}
to REFRESH-FUNC and that of @code{magit-refresh-args} to REFRESH-ARGS.
Finally it creates the buffer content by calling REFRESH-FUNC with
REFRESH-ARGS as arguments.

All arguments are evaluated before switching to BUFFER.
@end defmac

@defun magit-mode-display-buffer buffer mode &optional switch-function

This function display BUFFER in some window and select it.  BUFFER
may be a buffer or a string, the name of a buffer.  The buffer is
returned.

Unless BUFFER is already displayed in the selected frame, store the
previous window configuration as a buffer local value, so that it
can later be restored by @code{magit-mode-bury-buffer}.

The buffer is displayed and selected using SWITCH-FUNCTION.  If that
is @code{nil} then @code{pop-to-buffer} is used if the current buffer's major mode
derives from @code{magit-mode}.  Otherwise @code{switch-to-buffer} is used.
@end defun

@defvar magit-refresh-function

The value of this buffer-local variable is the function used to
refresh the current buffer.  It is called with @code{magit-refresh-args} as
arguments.
@end defvar

@defvar magit-refresh-args

The list of arguments used by @code{magit-refresh-function} to refresh the
current buffer.  @code{magit-refresh-function} is called with these
arguments.

The value is usually set using @code{magit-mode-setup}, but in some cases
it's also useful to provide commands which can change the value.  For
example, the @code{magit-diff-refresh-popup} can be used to change any of
the arguments used to display the diff, without having to specify
again which differences should be shown.  @code{magit-diff-more-context},
@code{magit-diff-less-context}, and @code{magit-diff-default-context} change just
the @code{-U<N>} argument.  In both case this is done by changing the value
of this variable and then calling this @code{magit-refresh-function}.
@end defvar

@node Conventions
@section Conventions

@menu
* Confirmation and Completion::
* Theming Faces::
@end menu

@node Confirmation and Completion
@subsection Confirmation and Completion

Dangerous operations that may lead to data loss have to be confirmed
by default.  With a multi-section selection, this is done using
questions that can be answered with "yes" or "no".  When the region isn't
active, or if it doesn't constitute a valid section selection, then
such commands instead read a single item in the minibuffer.  When the
value of the current section is among the possible choices, then that
is presented as default choice.  To confirm the action on a single
item, the user has to answer @code{RET} (instead of "yes"), and to abort, @code{C-g}
(instead of "no").  But alternatively the user may also select another
item, just like if the command had been invoked with no suitable
section at point at all.

@node Theming Faces
@subsection Theming Faces

The default theme uses blue for local branches, green for remote
branches, and goldenrod (brownish yellow) for tags.  When creating a
new theme, you should probably follow that example.  If your theme
already uses other colors, then stick to that.

In older releases these reference faces used to have a background
color and a box around them.  The basic default faces no longer do so,
to make Magit buffers much less noisy, and you should follow that
example at least with regards to boxes.  (Boxes were used in the past
to work around a conflict between the highlighting overlay and text
property backgrounds.  That's no longer necessary because highlighting no
longer causes other background colors to disappear.)  Alternatively
you can keep the background color and/or box, but then have to take
special care to adjust @code{magit-branch-current} accordingly.  By default
it looks mostly like @code{magit-branch-local}, but with a box (by default
the former is the only face that uses a box, exactly so that it sticks
out).  If the former also uses a box, then you have to make sure that
it differs in some other way from the latter.

The most difficult faces to theme are those related to diffs,
headings, highlighting, and the region.  There are faces that fall
into all four groups - expect to spend some time getting this right.

The @code{region} face in the default theme, in both the light and dark
variants, as well as in many other themes, distributed with Emacs or
by third-parties, is very ugly.  It is common to use a background
color that really sticks out, which is ugly but if that were the only
problem then it would be acceptable.  Unfortunately many themes also
set the foreground color, which ensures that all text within the
region is readable.  Without doing that there might be cases where
some foreground color is too close to the region background color to
still be readable.  But it also means that text within the region
loses all syntax highlighting.

I consider the work that went into getting the @code{region} face right to be
a good indicator for the general quality of a theme.  My
recommendation for the @code{region} face is this: use a background color
slightly different from the background color of the @code{default} face, and
do not set the foreground color at all.  So for a light theme you
might use a light (possibly tinted) gray as the background color of
@code{default} and a somewhat darker gray for the background of @code{region}.
That should usually be enough to not collide with the foreground color
of any other face.  But if some other faces also set a light gray as
background color, then you should also make sure it doesn't collide
with those (in some cases it might be acceptable though).

Magit only uses the @code{region} face when the region is "invalid" by its
own definition.  In a Magit buffer the region is used to either select
multiple sibling sections, so that commands which support it act on
all of these sections instead of just the current section, or to
select lines within a single hunk section.  In all other cases, the
section is considered invalid and Magit won't act on it.  But such
invalid sections happen, either because the user has not moved point
enough yet to make it valid or because she wants to use a non-magit
command to act on the region, e.g. @code{kill-region}.

So using the regular @code{region} face for invalid sections is a feature.  It
tells the user that Magit won't be able to act on it.  It's acceptable
if that face looks a bit odd and even (but less so) if it collides
with the background colors of section headings and other things that
have a background color.

Magit highlights the current section.  If a section has subsections,
then all of them are highlighted.  This is done using faces that have
"highlight" in their names.  For most sections, @code{magit-section-highlight}
is used for both the body and the heading.  Like the @code{region} face, it
should only set the background color to something similar to that of
@code{default}.  The highlight background color must be different from both
the @code{region} background color and the @code{default} background color.

For diff related sections Magit uses various faces to
highlight different parts of the selected section(s).  Note that hunk
headings, unlike all other section headings, by default have a
background color, because it is useful to have very visible separators
between hunks.  That face @code{magit-diff-hunk-heading}, should be different
from both @code{magit-diff-hunk-heading-highlight} and
@code{magit-section-highlight}, as well as from @code{magit-diff-context} and
@code{magit-diff-context-highlight}.  By default we do that by changing the
foreground color.  Changing the background color would lead to
complications, and there are already enough we cannot get around.
(Also note that it is generally a good idea for section headings to
always be bold, but only for sections that have subsections).

When there is a valid region selecting diff-related sibling sections,
i.e. multiple files or hunks, then the bodies of all these sections
use the respective highlight faces, but additionally the headings
instead use one of the faces @code{magit-diff-file-heading-selection} or
@code{magit-diff-hunk-heading-selection}.  These faces have to be different
from the regular highlight variants to provide explicit visual
indication that the region is active.

When theming diff related faces, start by setting the option
@code{magit-diff-refine-hunk} to @code{all}.  You might personally prefer to only
refine the current hunk or not use hunk refinement at all, but some of
the users of your theme want all hunks to be refined, so you have to
cater to that.

(Also turn on @code{magit-diff-highlight-indentation},
@code{magit-diff-highlight-trailing}, and @code{magit-diff-paint-whitespace}; and
insert some whitespace errors into the code you use for testing.)

For e.g. "added lines" you have to adjust three faces:
@code{magit-diff-added}, @code{magit-diff-added-highlight}, and
@code{smerge-refined-added}.  Make sure that the latter works well with both
of the former, as well as @code{smerge-other} and @code{diff-added}.  Then do the
same for the removed lines, context lines, lines added by us, and
lines added by them.  Also make sure the respective added, removed,
and context faces use approximately the same saturation for both the
highlighted and unhighlighted variants.  Also make sure the file and
diff headings work nicely with context lines (e.g. make them look
different).  Line faces should set both the foreground and the
background color.  For example, for added lines use two different
greens.

It's best if the foreground color of both the highlighted and the
unhighlighted variants are the same, so you will need to have to find
a color that works well on the highlight and unhighlighted background,
the refine background, and the highlight context background.  When
there is an hunk internal region, then the added- and removed-lines
background color is used only within that region.  Outside the region
the highlighted context background color is used.  This makes it
easier to see what is being staged.  With an hunk internal region the
hunk heading is shown using @code{magit-diff-hunk-heading-selection}, and so
are the thin lines that are added around the lines that fall within
the region.  The background color of that has to be distinct enough
from the various other involved background colors.

Nobody said this would be easy.  If your theme restricts itself to a
certain set of colors, then you should make an exception here.
Otherwise it would be impossible to make the diffs look good in each
and every variation.  Actually you might want to just stick to the
default definitions for these faces.  You have been warned.  Also
please note that if you do not get this right, this will in some cases
look to users like bugs in Magit - so please do it right or not at
all.

@node FAQ
@appendix FAQ

The next two nodes lists frequently asked questions.  For a list of
frequently @strong{and recently} asked questions, i.e. questions that haven't
made it into the manual yet, see
@uref{https://github.com/magit/magit/wiki/FAQ}.

Please also use the @ref{Debugging Tools}.

@menu
* FAQ - How to @dots{}?::
* FAQ - Issues and Errors::
@end menu

@node FAQ - How to @dots{}?
@appendixsec FAQ - How to @dots{}?

@menu
* How to show git's output?::
* How to install the gitman info manual?::
* How to show diffs for gpg-encrypted files?::
* How does branching and pushing work?::
* Can Magit be used as @code{ediff-version-control-package}?::
@end menu

@node How to show git's output?
@appendixsubsec How to show git's output?

To show the output of recently run git commands, press @code{$} (or, if that
isn't available, @code{M-x magit-process-buffer}).  This will show a buffer
containing a section per git invocation; as always press @code{TAB} to expand
or collapse them.

By default git's output is only inserted into the process buffer if it
is run for side-effects.  When the output is consumed in some way then
also inserting it into the process buffer would be to expensive.  For
debugging purposes it's possible to do so anyway by setting
@code{magit-git-debug} to @code{t}.

@node How to install the gitman info manual?
@appendixsubsec How to install the gitman info manual?

Git's manpages can be exported as an info manual called @code{gitman}.
Magit's own info manual links to nodes in that manual instead of the
actual manpages because Info doesn't support linking to manpages.

Unfortunately some distributions do not install the @code{gitman} manual by
default and you will have to install a separate documentation package
to get it.

Magit patches Info adding the ability to visit links to the @code{gitman}
Info manual by instead viewing the respective manpage.  If you prefer
that approach, then set the value of @code{magit-view-git-manual-method} to
one of the supported packages @code{man} or @code{woman}, e.g.:

@lisp
(setq magit-view-git-manual-method 'man)
@end lisp

@node How to show diffs for gpg-encrypted files?
@appendixsubsec How to show diffs for gpg-encrypted files?

Git supports showing diffs for encrypted files, but has to be told to
do so.  Since Magit just uses Git to get the diffs, configuring Git
also affects the diffs displayed inside Magit.

@example
git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
echo "*.gpg filter=gpg diff=gpg" > .gitattributes
@end example

@node How does branching and pushing work?
@appendixsubsec How does branching and pushing work?

Please see @ref{Branching} and @uref{http://emacsair.me/2016/01/18/magit-2.4}

@node Can Magit be used as @code{ediff-version-control-package}?
@appendixsubsec Can Magit be used as @code{ediff-version-control-package}?

No, it cannot.  For that to work the functions @code{ediff-magit-internal}
and @code{ediff-magit-merge-internal} would have to be implemented, and they
are not.  These two functions are only used by the three commands
@code{ediff-revision}, @code{ediff-merge-revisions-with-ancestor}, and
@code{ediff-merge-revisions}.

These commands only delegate the task of populating buffers with
certain revisions to the "internal" functions.  The equally important
task of determining which revisions are to be compared/merged is not
delegated.  Instead this is done without any support whatsoever, from
the version control package/system - meaning that the user has to
enter the revisions explicitly.  Instead of implementing
@code{ediff-magit-internal} we provide @code{magit-ediff-compare}, which handles
both tasks like it is 2005.

The other commands @code{ediff-merge-revisions} and
@code{ediff-merge-revisions-with-ancestor} are normally not what you want
when using a modern version control system like Git.  Instead of
letting the user resolve only those conflicts which Git could not
resolve on its own, they throw away all work done by Git and then
expect the user to manually merge all conflicts, including those that
had already been resolved.  That made sense back in the days when
version control systems couldn't merge (or so I have been told), but
not anymore.  Once in a blue moon you might actually want to see all
conflicts, in which case you @strong{can} use these commands, which then use
@code{ediff-vc-merge-internal}.  So we don't actually have to implement
@code{ediff-magit-merge-internal}.  Instead we provide the more useful
command @code{magit-ediff-resolve} which only shows yet-to-be resolved
conflicts.

@node FAQ - Issues and Errors
@appendixsec FAQ - Issues and Errors

@menu
* Magit is slow::
* I changed several thousand files at once and now Magit is unusable::
* I am having problems committing::
* I am using MS Windows and cannot push with Magit::
* I am using OS X and SOMETHING works in shell, but not in Magit: I am using OS X and SOMETHING works in shell but not in Magit. 
* Diffs contain control sequences::
* Expanding a file to show the diff causes it to disappear::
* Point is wrong in the @code{COMMIT_EDITMSG} buffer::
* The mode-line information isn't always up-to-date::
* Emacs 24.5 hangs when loading Magit: Emacs 245 hangs when loading Magit. 
@end menu

@node Magit is slow
@appendixsubsec Magit is slow

See @ref{Performance}.

@node I changed several thousand files at once and now Magit is unusable
@appendixsubsec I changed several thousand files at once and now Magit is unusable

Magit is @strong{currently} not expected to work under such conditions. It sure
would be nice if it did, and v2.5 will hopefully be a big step into
that direction.  But it might take until v3.1 to accomplish fully
satisfactory performance, because that requires some heavy refactoring.

But for now we recommend you use the command line to complete this one
commit.  Also see @ref{Performance}.

@node I am having problems committing
@appendixsubsec I am having problems committing

That likely means that Magit is having problems finding an appropriate
emacsclient executable.  See @ref{Configuring With-Editor,,,with-editor,}
and @ref{Debugging,,,with-editor,}.

@node I am using MS Windows and cannot push with Magit
@appendixsubsec I am using MS Windows and cannot push with Magit

It's almost certain that Magit is only incidental to this issue.  It
is much more likely that this is a configuration issue, even if you
can push on the command line.

Detailed setup instructions can be found at
@uref{https://github.com/magit/magit/wiki/Pushing-with-Magit-from-Windows}.

@node I am using OS X and SOMETHING works in shell but not in Magit
@appendixsubsec I am using OS X and SOMETHING works in shell, but not in Magit

This usually occurs because Emacs doesn't have the same environment
variables as your shell.  Try installing and configuring
@uref{https://github.com/purcell/exec-path-from-shell}.  By default it
synchronizes @code{$PATH}, which helps Magit find the same @code{git} as the one you
are using on the shell.

If SOMETHING is "passphrase caching with gpg-agent for commit and/or
tag signing", then you'll also need to synchronize @code{$GPG_AGENT_INFO}.

@node Diffs contain control sequences
@appendixsubsec Diffs contain control sequences

This happens when you configure Git to always color diffs and/or all
of its output.  The valid values for relevant Git variables @code{color.ui}
and @code{color.diff} are @code{false}, @code{true} and @code{always}, and the default is @code{true}.
You should leave it that because then you get colorful output in
terminals but git's output is consumed by something else, then no
colors are used.

If you actually use some other tool which expects that requires that
you force git to output control sequences (which is highly unlikely),
then you can override these settings just for Magit by using:

@lisp
(setq magit-git-global-arguments
      (nconc magit-git-global-arguments
             '("-c" "color.ui=false"
               "-c" "color.diff=false")))
@end lisp

@node Expanding a file to show the diff causes it to disappear
@appendixsubsec Expanding a file to show the diff causes it to disappear

This is probably caused by a change of a @code{diff.*} Git variable.  You
probably set that variable for a reason, and should therefore
only undo that setting in Magit by customizing
@code{magit-git-global-arguments}.

@node Point is wrong in the @code{COMMIT_EDITMSG} buffer
@appendixsubsec Point is wrong in the @code{COMMIT_EDITMSG} buffer

Neither Magit nor `git-commit` fiddle with point in the buffer used to
write commit messages, so something else must be doing it.

You have probably globally enabled a mode which does restore point in
file-visiting buffers.  It might be a bit surprising, but when you
write a commit message, then you are actually editing a file.

So you have to figure out which package is doing.  @code{saveplace},
@code{pointback}, and @code{session} are likely candidates.  These snippets might
help:

@lisp
(setq session-name-disable-regexp "\\(?:\\`'\\.git/[A-Z_]+\\'\\)")

(with-eval-after-load 'pointback
  (lambda ()
    (when (or git-commit-mode git-rebase-mode)
      (pointback-mode -1))))
@end lisp

@node The mode-line information isn't always up-to-date
@appendixsubsec The mode-line information isn't always up-to-date

Magit is not responsible for the version control information that is
being displayed in the mode-line and looks something like @code{Git-master}.
The built-in "Version Control" package, also known as "VC", updates
that information, and can be told to do so more often:

@lisp
(setq auto-revert-check-vc-info t)
@end lisp

But doing so isn't good for performance.  For more (overly optimistic)
information see @ref{VC Mode Line,,,emacs,}.

If you don't really care about seeing that information in the
mode-line, but just don't want to see @emph{incorrect} information, then
consider disabling VC when using Git:

@lisp
(setq vc-handled-backends (delq 'Git vc-handled-backends))
@end lisp

Or to disable it completely:

@lisp
(setq vc-handled-backends nil)
@end lisp

@node Emacs 245 hangs when loading Magit
@appendixsubsec Emacs 24.5 hangs when loading Magit

This is actually triggered by loading Tramp.  See
@uref{https://debbugs.gnu.org/cgi/bugreport.cgi?bug=20015} for details. You
can work around the problem by setting
@code{tramp-ssh-controlmaster-options}. Changing your DNS server (e.g. to
Google's @code{8.8.8.8}) may also be sufficient to work around the issue.

@node Debugging Tools
@chapter Debugging Tools

Magit and its dependencies provide a few debugging tools, and we
appreciate it very much if you use those tools before reporting an
issue.  Please include all relevant output when reporting an
issue.

@table @asis
@kindex M-x magit-version
@cindex magit-version
@item @kbd{M-x magit-version} @tie{}@tie{}@tie{}@tie{}(@code{magit-version})

This command shows the currently used versions of Magit, Git, and
Emacs in the echo area.  Non-interactively this just returns the
Magit version.

@kindex M-x magit-emacs-Q-command
@cindex magit-emacs-Q-command
@item @kbd{M-x magit-emacs-Q-command} @tie{}@tie{}@tie{}@tie{}(@code{magit-emacs-Q-command})

This command shows a debugging shell command in the echo area and
adds it to the kill ring.  Paste that command into a shell an run
it.

This shell command starts @code{emacs} with only @code{magit} and its
dependencies loaded.  Neither your configuration nor other installed
packages are loaded.  This makes it easier to determine whether some
issue lays with Magit or something else.

@kindex M-x magit-debug-git-executable
@cindex magit-debug-git-executable
@item @kbd{M-x magit-debug-git-executable} @tie{}@tie{}@tie{}@tie{}(@code{magit-debug-git-executable})

This command displays a buffer containing information about the
available and used @code{git} executable(s), and can be useful when
investigating @code{exec-path} issues.

Also see @ref{Git Executable}.

@kindex M-x with-editor-debug
@cindex with-editor-debug
@item @kbd{M-x with-editor-debug} @tie{}@tie{}@tie{}@tie{}(@code{with-editor-debug})

This command displays a buffer containing information about the
available and used @code{git} executable(s), and can be useful when
investigating why Magit (or rather @code{with-editor}) cannot find an
appropriate @code{emacsclient} executable.

Also see @ref{Debugging,,,with-editor,}.
@end table

Please also see the @ref{FAQ}.

@node Keystroke Index
@appendix Keystroke Index

@printindex ky

@node Command Index
@appendix Command Index

@printindex cp

@node Function Index
@appendix Function Index

@printindex fn

@node Variable Index
@appendix Variable Index

@printindex vr

@bye
